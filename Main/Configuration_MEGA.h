#ifndef _CONFIGURATION_MEGA_H
#define _CONFIGURATION_MEGA_H

#if (TARGET_BOARD != MEGA_BOARD)
  #error "Target board MUST BE MEGA_BOARD for this configuration!"
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// USER SETTINGS
// ПОЛЬЗОВАТЕЛЬСКИЕ НАСТРОЙКИ
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------------------------------------------------
// директивы условной компиляции:
/*
    в общем случае для предварительной настройки прошивки достаточно закомментировать ту или иную директиву USE_*.
    конкретные настройки пинов и пр. - находятся после директив условной компиляции, и подхватываются только тогда,
    когда соответствующая директива USE_* определена.
 */
//--------------------------------------------------------------------------------------------------------------------------------
// uncomment this line if you need to measure temperatures in Fahrenheit instead of Celsius
// раскомментируйте эту настройку, если вам надо измерять температуру не в градусах Цельсия, а в Фаренгейтах
//#define MEASURE_TEMPERATURES_IN_FAHRENHEIT 
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не хотим использовать модуль реального времени (DS3231)
// без этого модуля многий функционал не работает, например, логгирование информации или работа модуля полива по расписанию.
// можно считать, что использование этого модуля - обязательно.
// start this line with comment, if you don't want to use DS3231 realtime clock (not recommended, this device used by some modules)
#define USE_DS3231_REALTIME_CLOCK 
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужен модуль управления пинами
// этот модуль косвенно используют другие модули (например, модуль составных команд) для управления пинами
// start this line with comment, if you don't want to use PIN module (drive pins by using commands like CTSET=PIN|13|ON etc.) 
#define USE_PIN_MODULE 
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужно управление окнами по температуре
// start this line with comment, if you don't want to use STATE module (drive windows and holds temperature from DS18*20 sensors)
#define USE_TEMP_SENSORS
//--------------------------------------------------------------------------------------------------------------------------------
// использовать ли сдвиговый регистр 74HC595 для управления окнами, вместо контроля пинов напрямую (см. настройки фрамуг ниже)
// start this line with comment, if you don't want to use 74HC595 shift register to drive the windows, and  want the direct drive trough pins. See settings below.
#define USE_WINDOWS_SHIFT_REGISTER
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужна поддержка модуля статистики (FREERAM, UPTIME, DATETIME)
// start this line with comment, if you don't want to use STAT module (FREERAM, UPTIME, DATETIME commands)
#define USE_STAT_MODULE
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужна поддержка управления по SMS (SIM800)
// start this line with comment, if you don't want to use GSM module (SIM800)
#define USE_SMS_MODULE
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужен модуль управления поливом (в принципе, тот же функционал можно реализовать через правила)
// start this line with comment, if you don't want to use watering module
#define USE_WATERING_MODULE
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужен модуль контроля освещенности (BH1750 и MAX44009)
// start this line with comment, if you don't want to use luminosity module (BH17500 and MAX44009 sensors)
#define USE_LUMINOSITY_MODULE 
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_HUMIDITY_MODULE // закомментировать, если не нужен модуль работы с датчиками влажности DHT, Si7021, SHT
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_SOIL_MOISTURE_MODULE // закомментировать, если не нужен модуль датчиков влажности почвы
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_PH_MODULE // закомментировать, если не нужен модуль снятия показаний с датчиков pH и контроля за дозированием реагентов в систему
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_LOG_MODULE // закомментировать, если не нужен модуль логгирования информации. Внимание: модуль работает только с модулем реального времени (USE_DS3231_REALTIME_CLOCK должна быть определена!)
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_DELTA_MODULE // закомментировать, если не нужно собирать показания дельт с датчиков (разница показаний между двумя датчиками)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WATERFLOW_MODULE // закомментировать, если не нужны датчик(и) расхода воды (пин(ы) 2 (и 3) меги), настройки - см. ниже
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_COMPOSITE_COMMANDS_MODULE // закомментировать, если не нужен модуль составных команд (позволяет выполнить скопом несколько разных действий, используется правилами)
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_RESERVATION_MODULE // закомментировать, если не нужем модуль резервирования датчиков (когда при отсутствии показаний с одного датчика показания берутся со связанных с ним).
// модуль резервирования нужен для работы правил, если необходимо обеспечить работу правила даже тогда, когда один из датчиков вышел из строя
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_TIMER_MODULE // закомментировать, если не нужна поддержка модуля таймеров (4 таймера)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_IOT_MODULE // закомментировать, если не нужна отсылка данных на IoT-хранилища (ThingSpeak). Настройки IoT смотрите ниже
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_ALARM_DISPATCHER // закомментировать, если не нужны тревоги (получение СМС при срабатывании правила)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании ESP (если ESP долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_GSM_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании модема (если GSM-модем долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_NRF_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании nRF (если nRF долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_LORA_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании LoRa (если LoRa долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_W5100_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании W5100 (если W5100 долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_EXTERNAL_WATCHDOG // закомментировать, если не нужен внешний контроль зависания меги (мега на определённой ноге дёргает уровни, если уровни не меняются - внешний ватчдог передёргивает питание)
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать ESP как один из шлюзов для отсыла данных в IoT
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE_AS_HTTP_PROVIDER // закомментировать, если не хотим посылать HTTP-запросы к сервису gardenboss.ru через ESP
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE_AS_MQTT_CLIENT // раскомментировать, если хотим использовать ESP как MQTT-клиент
//--------------------------------------------------------------------------------------------------------------------------------
#define MQTT_REPORT_AS_JSON // раскомментировать, если надо публиковать топик-ответ на выполнение команды в объекте JSON
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_GSM_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать GSM-модем как один из шлюзов для отсыла данных в IoT
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_GSM_MODULE_AS_HTTP_PROVIDER // закомментировать, если не хотим посылать HTTP-запросы к сервису gardenboss.ru через GSM
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужно использовать никакие универсальные модули (если эта директива закомментирована - модули любых типов не используются),
// если раскомментирована - используются модули с датчиками на борту, исполнительные модули - используются в зависимости от настройки USE_UNI_EXECUTION_MODULE).
// если эта строка закомментирована - никакие из модулей использоваться не будут
#define USE_UNIVERSAL_MODULES
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не надо использовать выносной модуль на 7 кнопок с привязками к командам (прошивка UniversalControlModule)
#define USE_RS485_EXTERNAL_CONTROL_MODULE
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_UNI_NEXTION_MODULE // закомментировать, если не нужен выносной модуль с дисплеем Nextion на шине 1-Wire
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_UNI_EXECUTION_MODULE // закомментировать, если не нужна поддержка универсальных исполнительных модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_UNI_REGISTRATION_LINE // закомментировать, если не нужна проводная линия 1-Wire для регистрации универсальных модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_RS485_GATE // закомментировать, если не нужна поддержка опроса универсальных модулей по протоколу RS-485
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_NRF_GATE // закомментировать, если не нужно работать с универсальными модулями по радиоканалу nRF
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_LORA_GATE // закомментировать, если не нужно работать с универсальными модулями по радиоканалу LoRa (чипы SX1276/77/78/79)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_PUMP_RELAY // закомментировать, если не нужен отдельный канал управления насосом при поливе (настройки - ниже)
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_SECOND_PUMP // использовать ли второй насос для полива (настройки - ниже). Директива USE_PUMP_RELAY при использовании второго насоса также должна быть определена!
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_HTTP_MODULE // закомментировать, если не нужна проверка на входящие команды и отсыл данных на сервис gardenboss.ru
//--------------------------------------------------------------------------------------------------------------------------------
// расширители портов
//--------------------------------------------------------------------------------------------------------------------------------

// использовать или нет расширители портов MCP23S17, при этом модули, которые поддерживают работу через эти расширители, могут работать через них. 
// Настройки расширителя на SPI смотрите ниже.

// раскомментировать, если хотите использовать MCP23S17 (работу через них поддерживает модуль полива и модуль досветки, а также другой функционал)
//#define USE_MCP23S17_EXTENDER

// использовать или нет расширители портов MCP23017, при этом модули, которые поддерживают работу через эти расширители, могут работать через них. 
// Настройки расширителя на I2C смотрите ниже.

// раскомментировать, если хотите использовать MCP23017 (работу через них поддерживает модуль полива и модуль досветки, а также другой функционал)
//#define USE_MCP23017_EXTENDER

//--------------------------------------------------------------------------------------------------------------------------------
// шлюзы (ИСПОЛЬЗОВАТЬ ВМЕСТЕ НЕ ДОПУСКАЕТСЯ, прошивка не скомпилируется!)
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужна поддержка управления через Wi-Fi (ESP8266) (не работает совместно с USE_W5100_MODULE!)
// порт, на котором ESP слушает входящие команды в режиме точки доступа - 1975.
// ПРОШИВКА ДЛЯ ESP НАХОДИТСЯ В ПАПКЕ ESP_AT - РАБОТОСПОСОБНОСТЬ ПРОВЕРЕНА ТОЛЬКО В СВЯЗКЕ С ЭТОЙ ПРОШИВКОЙ!!!
// ИНСТРУКЦИИ ПО ПРОШИВКЕ НАХОДЯТСЯ В ТОЙ ЖЕ ПАПКЕ, В ФАЙЛЕ README.TXT!!!
// НАСТОЯТЕЛЬНО РЕКОМЕНДУЕТСЯ ИСПОЛЬЗОВАТЬ ПИН УПРАВЛЕНИЕ ПИТАНИЕМ ДЛЯ ПОЛНОГО ПЕРЕСБРОСА ESP!!!
#define USE_WIFI_MODULE

// закомментировать, если не нужна работа по Ethernet через W5100 (не работает совместно с USE_WIFI_MODULE!)
// для W5100 реализован только простейший мост TCP-контроллер, т.е. через W5100 можно общаться с контроллером
// любыми понятными ему командами. Порт для W5100 - 1975.
//#define USE_W5100_MODULE

//--------------------------------------------------------------------------------------------------------------------------------
// экраны (ИСПОЛЬЗОВАТЬ ВМЕСТЕ НЕ ДОПУСКАЕТСЯ, прошивка не скомпилируется!)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_LCD_MODULE // закомментировать, если не нужен дисплей 128х64 на базе контроллера ST7920
//#define USE_NEXTION_MODULE // закомментировать, если не нужна поддержка Nextion

//--------------------------------------------------------------------------------------------------------------------------------
// информационные диоды
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_READY_DIODE // закомментировать, если не нужен диод, горящий при работе контроллера (пин номер DIODE_READY_PIN)
#define BLINK_READY_DIODE // закомментировать, если не нужно периодически мигать диодом работы
#define USE_WINDOWS_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления фрамугами (пин DIODE_WINDOWS_MANUAL_MODE_PIN)
#define USE_WATERING_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления поливом (пин DIODE_WATERING_MANUAL_MODE_PIN)
#define USE_LIGHT_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления досветкой (пин DIODE_LIGHT_MANUAL_MODE_PIN)

//--------------------------------------------------------------------------------------------------------------------------------
// менеджер обратной связи для окон (универсальный модуль, который отдаёт информацию о положении окон и срабатывании концевиков)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_FEEDBACK_MANAGER // закомментировать, если не нужно использовать модуль обратной связи по положению окон
// (прошивка UniversalExecutionModule с включенной обратной связью)
#define FEEDBACK_MANAGER_WAIT_TIME 15000 // если в течение указанного кол-ва миллисекунд после старта контроллера не придёт информация
// по положению окон - окна принудительно погонятся контроллером в закрытую позицию, чтобы обеспечить начальную точку отсчёта
#define FEEDBACK_MANAGER_UPDATE_INTERVAL 5000 // через сколько миллисекунд запрашивать информацию у модулей обратной связи
#define FEEDBACK_MANAGER_POSITION_HISTERESIS 500 // кол-во миллисекунд работы моторов, которое следует игнорировать, если текущая позиция окон
// находится в рамках этого гистерезиса, т.е. разница текущей позиции и запрошенной - меньше гистерезиса

//--------------------------------------------------------------------------------------------------------------------------------
/*
 ниже идут конкретные настройки того или иного функционала.
 */

//--------------------------------------------------------------------------------------------------------------------------------
// настройки расширителей портов MCP23S17 (актуально при раскомментированной команде USE_MCP23S17_EXTENDER)
//--------------------------------------------------------------------------------------------------------------------------------
#define MCP23S17_CS_PIN 10 // номер пина chip select для микросхем MCP23S17
#define COUNT_OF_MCP23S17_EXTENDERS 0 // сколько расширителей портов MCP23S17 используется (0 - нисколько)
#define MCP23S17_ADDRESSES 0, 1 // адреса расширителей MCP23S17, через запятую, кол-вом COUNT_OF_MCP23S17_EXTENDERS

//--------------------------------------------------------------------------------------------------------------------------------
// настройки расширителей портов MCP23017 (актуально при раскомментированной команде USE_MCP23017_EXTENDER)
//--------------------------------------------------------------------------------------------------------------------------------
#define COUNT_OF_MCP23017_EXTENDERS 0 // сколько расширителей портов MCP23017 используется (0 - нисколько)
// адреса расширителей MCP23017, через запятую, кол-вом COUNT_OF_MCP23017_EXTENDERS
// 0 - первый адрес 0x20, 1 - второй адрес 0x21 и т.п.
#define MCP23017_ADDRESSES 4,5 

//--------------------------------------------------------------------------------------------------------------------------------
// НАСТРОЙКИ ВНЕШНЕГО ВАТЧДОГА (актуально при раскомментированной команде USE_EXTERNAL_WATCHDOG)
//--------------------------------------------------------------------------------------------------------------------------------
#define WATCHDOG_REBOOT_PIN A5 // номер пина, на котором будут меняться уровни
#define WATCHDOG_NORMAL_LEVEL LOW // уровень на ноге, который держится WATCHDOG_WORK_INTERVAL миллисекунд
#define WATCHDOG_TRIGGERED_LEVEL HIGH // уровень импульса на ноге, который держится WATCHDOG_PULSE_DURATION миллисекунд
#define WATCHDOG_WORK_INTERVAL 5000 // через сколько миллисекунд на ноге будет уровень WATCHDOG_TRIGGERED_LEVEL
#define WATCHDOG_PULSE_DURATION 20 // сколько миллисекунд держать уровень WATCHDOG_TRIGGERED_LEVEL на ноге

//--------------------------------------------------------------------------------------------------------------------------------
// НАСТРОЙКИ УНИВЕРСАЛЬНЫХ МОДУЛЕЙ (актуально при раскомментированной команде USE_UNIVERSAL_MODULES)
//--------------------------------------------------------------------------------------------------------------------------------
#define UNI_REGISTRATION_PIN 28 // номер пина, на котором будут регистрироваться модули в системе (актуально при раскомментированной команде USE_UNI_REGISTRATION_LINE)
#define UNI_MODULE_UPDATE_INTERVAL 2000 // через сколько мс обновлять показания с универсального модуля
#define UNI_WIRED_MODULES_COUNT 1 // сколько проводных линий для универсальных модулей используется (0 - нисколько)
// ДЛЯ ПЛАТЫ ВЫВОДЫ ПО УМОЛЧАНИЮ, ПОДТЯНУТЫЕ РЕЗИСТОРАМИ - A11, A12, A13
#define UNI_WIRED_MODULES A12 // номера пинов (через запятую), на которых висят универсальные модули, кол-вом  UNI_WIRED_MODULES_COUNT

// показания с каких датчиков передавать выносному модулю с дисплеем Nextion? максимум 5 датчиков (актуально при раскомментированной команде USE_UNI_NEXTION_MODULE)
#define UNI_NEXTION_WAIT_SCREEN_SENSORS {StateTemperature,0,"STATE"}, {StateHumidity,1,"HUMIDITY"}, {StateLuminosity,0,"LIGHT"}

//--------------------------------------------------------------------------------------------------------------------------------
// настройки RS-485 (актуально при раскомментированной команде USE_RS485_GATE)
//--------------------------------------------------------------------------------------------------------------------------------
#define RS_485_SERIAL Serial3 // ВНИМАНИЕ! СЛЕДИТЕ ЗА ОТСУТСТВИЕМ КОНФЛИКТОВ С SERIAL. ЭТОТ ЖЕ SERIAL ИСПОЛЬЗУЕТСЯ Nextion, т.е. либо Nextion по Serial, либо - RS-485!!!
#define RS_485_UCSR UCSR3A // регистр, связанный с номером UART RS_485_SERIAL
#define RS_485_TXC TXC3 // бит ТХ, связанный с номером UART RS_485_SERIAL
#define RS_485_DE_PIN 26 // номер пина, на котором будет происходить переключение приёма/передачи по RS-485
#define RS485_SPEED 57600 // скорость работы по RS-485
#define RS485_STATE_PUSH_FREQUENCY 1000 // через сколько миллисекунд писать в шину RS-485 слепок состояния контроллера
#define RS485_ONE_SENSOR_UPDATE_INTERVAL 1234 // через сколько миллисекунд запрашивать с шины RS-485 показания одного датчика (полный цикл опроса будет равен интервалу*кол-во датчиков в системе)
#define RS485_BYTES_TIMEOUT 10 // кол-во байт, после неуспешной попытки вычитки которых принимать решение о таймауте (если данные по RS-485 не ходят - увеличьте это значение).
#define RS485_RESET_SENSOR_AFTER_N_BAD_READINGS 5 // через сколько неудачных чтений с датчика сбрасывать его значения на вид "<нет данных>"
//--------------------------------------------------------------------------------------------------------------------------------
// настройки nRF (актуально при раскомментированной команде USE_NRF_GATE)
//--------------------------------------------------------------------------------------------------------------------------------
#define UNI_DEFAULT_RF_CHANNEL 19 // номер канала для nRF по умолчанию
#define NRF_CE_PIN A8 // номер пина CE для модуля nRF
#define NRF_CSN_PIN A9 // номер пина CSN для модуля nRF
#define NRF_CONTROLLER_STATE_CHECK_FREQUENCY 789 // через сколько миллисекунд проверять смену состояния контроллера (для отсылки в эфир при изменениях)
// номер пина для пересброса питания nRF (в текущей версии управление питанием не реализовано - на этот пин для платы просто подаётся нужный уровень)
#define NRF_REBOOT_PIN 30 // (актуально при раскомментированной команде USE_NRF_REBOOT_PIN) 
#define NRF_POWER_ON HIGH
#define NRF_POWER_OFF LOW
// раскомментировать эту строчку здесь и в прошивках универсальных модулей, если у вас они не коннектятся. 
// Иногда auto aсk в китайских модулях имеет инвертированное значение.
//#define NRF_AUTOACK_INVERTED 
//--------------------------------------------------------------------------------------------------------------------------------
// настройки LoRa (актуально при раскомментированной команде USE_LORA_GATE)
//--------------------------------------------------------------------------------------------------------------------------------
#define LORA_SS_PIN A9 // пин SS для LoRa
#define LORA_RESET_PIN A8 // пин Reset для LoRa
#define LORA_FREQUENCY 433E6 // частота работы (433E6, 866E6, 915E6)
#define LORA_TX_POWER 17 // мощность передатчика (1 - 17)
#define LORA_CONTROLLER_STATE_CHECK_FREQUENCY 789 // через сколько миллисекунд проверять смену состояния контроллера (для отсылки в эфир при изменениях)
// номер пина для пересброса питания LoRa (в текущей версии управление питанием не реализовано - на этот пин для платы просто подаётся нужный уровень)
#define LORA_REBOOT_PIN 30 // (актуально при раскомментированной команде USE_LORA_REBOOT_PIN) 
#define LORA_POWER_ON HIGH
#define LORA_POWER_OFF LOW
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля периодических таймеров, 4 штуки (актуально при раскомментированной команде USE_TIMER_MODULE) 
//--------------------------------------------------------------------------------------------------------------------------------
#define TIMER_ON HIGH // уровень, который надо выставлять на пине, когда таймер включён
#define TIMER_OFF LOW // уровень, который надо выставлять на пине, когда таймер выключён

//--------------------------------------------------------------------------------------------------------------------------------
// настройки EEPROM для хранения данных
//--------------------------------------------------------------------------------------------------------------------------------
// тут определяем, какую память мы используем
//--------------------------------------------------------------------------------------------------------------------------------
#define EEPROM_USED_MEMORY EEPROM_BUILTIN // по умолчанию используем встроенную в мегу память (типы памяти см. в Configaration_Shared.h)
// если используется внешнняя память AT24C* - то ниже определяется индекс микросхемы. Например, китайский модуль часов реального времени
// с DS3231 на борту имеет модуль памяти с адресом на шине I2C 0x57, т.е. индекс такого модуля - 7, т.к. базовый адрес памяти на шине - 
// 0x50. Настройкой ниже можно указать адрес микросхемы памяти на шине I2C.
#define EEPROM_MEMORY_INDEX 0
//--------------------------------------------------------------------------------------------------------------------------------
#define SETT_HEADER1 0x1F // байты, сигнализирующие о наличии сохранённых настроек, первый
#define SETT_HEADER2 0xBF // и второй

//--------------------------------------------------------------------------------------------------------------------------------
// адреса хранения данных в EEPROM (МИНИМАЛЬНЫЙ ОБЪЁМ EEPROM - 4 Кб !!!)
//--------------------------------------------------------------------------------------------------------------------------------

#define CONTROLLER_ID_EEPROM_ADDR 1 // по какому адресу располагается ID контроллера, 1 байт
#define UNI_SENSOR_INDICIES_EEPROM_ADDR 2 // с какого адреса идут выданные индексы для универсальных сенсоров, 10 байт

#define WIFI_STATE_EEPROM_ADDR 12// адрес хранения состояния Wi-Fi (коннектится к роутеру или нет), 1 байт
#define STATION_PASSWORD_EEPROM_ADDR 13// адрес хранения пароля к точке ESP, 20 байт
#define STATION_ID_EEPROM_ADDR 33// адрес хранения ID точки доступа ESP, 20 байт
#define ROUTER_PASSWORD_EEPROM_ADDR 53// адрес хранения пароля к роутеру, 20 байт
#define ROUTER_ID_EEPROM_ADDR 73// адрес хранение ID роутера, 20 байт

#define SMS_NUMBER_EEPROM_ADDR 93 // адрес хранения номера телефона хозяина, 15 байт
#define GSM_PROVIDER_EEPROM_ADDR 108 // адрес хранения оператора GSM, 1 байт

#define IOT_SETTINGS_EEPROM_ADDR 109 // адрес хранения настроек IOT, 51 байт
#define OPEN_INTERVAL_EEPROM_ADDR 160 // адрес хранения настроек интервала открытия окон, 4 байта
#define CLOSE_TEMP_EEPROM_ADDR 164 // адрес хранения температуры закрытия, 1 байт
#define OPEN_TEMP_EEPROM_ADDR 165 // адрес хранения температуры открытия, 1 байт

#define WATERING_OPTION_EEPROM_ADDR 166 // адрес хранения текущей опции полива, 1 байт
#define TURN_PUMP_EEPROM_ADDR 167 // адрес хранения флага - включить ли насос при поливе, 1 байт
#define START_WATERING_TIME_EEPROM_ADDR 168 // адрес хранения начала полива для всех каналов, 2 байта
#define WATERING_TIME_EEPROM_ADDR 170 // адрес хранения продолжительности полива для всех каналов, 2 байта
#define WATERING_WEEKDAYS_EEPROM_ADDR 172 // адрес хранения маски дней недели полива на всех каналах, 1 байт
#define WATERING_SENSOR_EEPROM_ADDR 173 // адрес хранения индекса датчика в модуле влажности почв, показания с которого учитываются при поливе, 1 байт
#define WATERING_STOP_BORDER_EEPROM_ADDR 174 // адрес хранения показаний с датчика, по которым полив на всех каналах выключается, 1 байт
#define WATERING_CHANNELS_SETTINGS_EEPROM_ADDR 175 // адрес начала настроек каналов полива, 16 каналов*7 байт на канал - 112 байт
#define WATERING_STATUS_EEPROM_ADDR 300 // с какого адреса у нас идут статусы каналов полива, по 5 байт на канал, 100 байт


#define WATERFLOW_EEPROM_ADDR 400 // с какого адреса у нас будут записываться показания датчиков расхода воды, 12 байт

#define DELTA_SETTINGS_EEPROM_ADDR 412 // с какого адреса в EEPROM начинаются настройки дельт, 500 байт на 20 дельт
#define PH_SETTINGS_EEPROM_ADDR 912 // с какого адреса идут настройки PH-модуля, 30 байт
#define TIMERS_EEPROM_ADDR 942 // у нас 4 таймера, на каждый - 10 байт + заголовок (2 байта), итого - 42 байта 
#define RESERVATION_ADDR 984 // адрес, с которого пишутся настройки резервирования (10 списков по 12 байт + 3 байта = 123 байта)
#define GUID_ADDRESS 1110 // адрес, по которому хранится уникальный GUID контроллера (32 символа без пробелов + 2 байта - заголовок присутствия - 34 байта)
#define HTTP_API_KEY_ADDRESS 1144 // адрес, ко которому хранится ключ доступа к HTTP API (32 символа без пробелов + 2 байта - заголовок присутствия + 1 байт - флаг активности, вкл/выкл) - 35 байт
#define HTTP_SEND_SENSORS_DATA_ADDRESS 1179 // адрес хранения флага - отсылать ли слепок показаний датчиков контроллера при проверке задач по HTTP, 1 байт
#define TIMEZONE_ADDRESS 1180 // адрес хранения часового пояса контроллера, 4 байта (2 байта заголовок присутствия, 2 байта - таймзона). Хранится в минутах
#define HTTP_SEND_STATUS_ADDRESS 1184 // адрес хранения флага - отсылать ли слепок состояния контроллера при проверке задач по HTTP, 1 байт

#define MQTT_ENABLED_FLAG_ADDRESS 1185 // адрес хранения флага - активен ли MQTT-клиент, 1 байт
#define MQTT_INTERVAL_BETWEEN_TOPICS_ADDRESS 1186 // адрес хранения интервала (в секундах) между публикацией топиков в брокер MQTT, 1 байт

#define EEPROM_RULES_START_ADDR 1200 // со второго килобайта в EEPROM идут правила
#define COMPOSITE_COMMANDS_START_ADDR 3248 // с четвёртого килобайта в EEPROM идут составные команды

//--------------------------------------------------------------------------------------------------------------------------------
// настройки Serial
//--------------------------------------------------------------------------------------------------------------------------------
#define SERIAL_BAUD_RATE 57600 // скорость работы с портом, бод (конфигуратор работает с портом именно на скорости 57600)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки информационных диодов 
//--------------------------------------------------------------------------------------------------------------------------------
// как рулим информационными диодами [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define INFO_DIODES_DRIVE_MODE DRIVE_DIRECT // по умолчанию - прямое управление
// адрес микросхемы MCP23S17, через которую рулим информационными диодами (если управление в режиме DRIVE_MCP23S17)
#define INFO_DIODES_MCP23S17_ADDRESS 1
// адрес микросхемы MCP23017, через которую рулим информационными диодами (если управление в режиме DRIVE_MCP23017)
#define INFO_DIODES_MCP23017_ADDRESS 0 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.
//--------------------------------------------------------------------------------------------------------------------------------
#define DIODE_READY_PIN 6 // пин или номер канала расширителя портов, на котором висит диод индикации работы (актуально при раскомментированной команде USE_READY_DIODE)
#define DIODE_WINDOWS_MANUAL_MODE_PIN 7 // пин или номер канала расширителя портов, на котором будет диод, мигающий, когда мы в ручном режиме управления окнами (актуально при раскомментированной команде USE_WINDOWS_MANUAL_MODE_DIODE)
#define DIODE_WATERING_MANUAL_MODE_PIN 8 // пин или номер канала расширителя портов, на котором висит диод индикации ручного режима управления поливом (актуально при раскомментированной команде USE_WATERING_MANUAL_MODE_DIODE)
#define DIODE_LIGHT_MANUAL_MODE_PIN 9 // пин или номер канала расширителя портов, на котором висит диод индикации ручного режима управления досветкой (актуально при раскомментированной команде USE_LIGHT_MANUAL_MODE_DIODE)

// интервалы мигания
#define WORK_MODE_BLINK_INTERVAL 500 // с какой частотой мигать на пинах индикации ручного режима работы, мс
#define READY_DIODE_BLINK_INTERVAL 5000 // с какой частотой мигать диодом работы, мс

//--------------------------------------------------------------------------------------------------------------------------------
// настройки SD и нумерации виртуальных пинов
//--------------------------------------------------------------------------------------------------------------------------------
#define SDCARD_CS_PIN 53 // номер пина Chip Select для SD-модуля 
#define VIRTUAL_PIN_START_NUMBER 80 // номер пина, с которого все пины будут считаться виртуальными, т.е. запись в них производиться не будет, однако в карте пинов (16 байт) этот статус будет отражён.

//--------------------------------------------------------------------------------------------------------------------------------
// настройки железных модулей реле 
//--------------------------------------------------------------------------------------------------------------------------------
#define RELAY_ON LOW // уровень для включения реле фрамуг
#define RELAY_OFF HIGH // уровень для выключения реле фрамуг
#define SHORT_CIRQUIT_STATE HIGH // статус пинов, на которых висит реле фрамуг, чтобы закоротить мотор и не дать ему крутиться

//--------------------------------------------------------------------------------------------------------------------------------
// настройки максимумов
//--------------------------------------------------------------------------------------------------------------------------------
#define MAX_ALERT_RULES 30 // максимальное кол-во поддерживаемых правил
#define MAX_DELTAS 20 // максимальное кол-во дельт. Внимание: на 20 дельт нужно примерно 500 байт в EEPROM, следите за непересечением адресов!!!

//--------------------------------------------------------------------------------------------------------------------------------
// настройки интервалов обновлений модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define ALERT_UPDATE_INTERVAL 500 // интервал обновления состояния модуля ALERT, мс. Нужен, чтобы часто не разрешать зависимости - это ресурсоёмкая операция.
//#define ALERT_INCLUDE_COMMA_VALUES // раскомментировать, если в правилах надо сравнивать не только целую часть показаний, но и дробную
#define LOGGING_INTERVAL 300000 // интервал логгирования, мс (300000 - каждые 5 минут и т.п.)
#define LUMINOSITY_UPDATE_INTERVAL 3000 // через сколько мс обновлять показания с датчиков освещенности 
#define HUMIDITY_UPDATE_INTERVAL 5000 // через сколько мс обновлять показания с датчиков влажности
#define TEMP_UPDATE_INTERVAL 4990 // через сколько мс обновлять показания с датчиков температуры
#define DELTA_UPDATE_INTERVAL 5010 // через сколько миллисекунд обновлять показания дельт?

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля освещенности (BH1750, MAX44009) (актуально при раскомментированной команде USE_LUMINOSITY_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// режимы управления пинами - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define LIGHT_DRIVE_MODE DRIVE_DIRECT // прямое управление пинами, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим каналами досветки (если управление в режиме DRIVE_MCP23S17)
#define LIGHT_MCP23S17_ADDRESS 1

// адрес микросхемы MCP23017, через которую рулим каналами досветки (если управление в режиме DRIVE_MCP23017)
#define LIGHT_MCP23017_ADDRESS 0 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// уровни для реле каналов досветки
#define LIGHT_RELAY_ON LOW // уровень для включения реле
#define LIGHT_RELAY_OFF HIGH // уровень для выключения реле

// Поддерживается максимум 4 датчика - два BH1750 и два - MAX44009
#define LIGHT_SENSORS_COUNT 2 // кол-во проводных датчиков освещенности на шине I2C, 0-4
#define LIGHT_SENSORS BH1750_SENSOR, MAX44009_SENSOR // типы датчиков, через запятую (для BH1750 - пишем BH1750_SENSOR, для MAX44009 - пишем MAX44009_SENSOR)
// количество записей должно быть равно LIGHT_SENSORS_COUNT !!!
// первый датчик любого типа имеет первый адрес датчика на шине I2C, второй упомянутый - следующий адрес на шине. Например,
// если записать BH1750_SENSOR, BH1750_SENSOR - то это значит, что подключены два датчика BH1750, и у первого - будет первый адрес, у второго - второй.

#define LAMP_RELAYS_COUNT 4 // кол-во реле для управления досветкой, максимум - 8 каналов

// пины, на которых сидят реле управления досветкой (через запятую, кол-во равно LAMP_RELAYS_COUNT!)
// в случае управления через расширители портов (DRIVE_MCP23S17, DRIVE_MCP23017) - номера каналов микросхемы 
#define LAMP_RELAYS_PINS 34,35,36,37 

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля контроля pH (РАБОТАЕТ ЧЕРЕЗ МИКРОСХЕМУ PCF8574T на шине I2C !!!) (актуально при раскомментированной команде USE_PH_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
/*
 Принцип работы модуля контроля pH:
 
   1. Все каналы заведены через микросхему PCF8574T, которую можно подсоединить как прямо к меге, 
      так и вытащить через удлинитель I2C;
      
   2. К одному из каналов подключен датчик понижения уровня жидкости в ёмкости с рабочим раствором, 
      который при срабатывании выдаёт сигнал определённого уровня;
      
   3. При срабатывании датчика уровня начинается пополнение ёмкости с рабочим раствором, для этого на канал, 
      к которому подключен клапан подачи воды - подаётся определённый уровень;
      
   4. Как только ёмкость заполнена - начинается контроль pH;
   
   5. При отклонении pH от нужных значений, в зависимости от направления отклонения - 
      на каналы клапанов для повышения/понижения значения pH подаётся нужный уровень;
      
   6. После подачи корректировочного раствора в нужном объёме на канал управление насосом, 
      перемешивающим рабочий раствор, подаётся нужный уровень;
      
   7. После окончания перемешивания система продолжает контролировать pH, периодически при необходимости 
      повторяя вышеописанные действия, чтобы добиться требуемого уровня pH.
   
 */
//--------------------------------------------------------------------------------------------------------------------------------
#define PCF8574_ADDRESS 0x27 // адрес микросхемы для контроля pH на шине I2C (0x20 - 0x27)
#define PH_SENSOR_PIN A14 // номер аналогового пина, с которого читать показания датчика (0 - нет датчика, прикреплённого к меге)
#define PH_SAMPLES_PER_MEASURE 10 // сколько делать замеров на одно измерение pH (1-255)
#define PH_SAMPLES_INTERVAL 20 // сколько миллисекунд между замерами в одном цикле измерения делать (10 - 255)
#define PH_UPDATE_INTERVAL 15678 // через сколько миллисекунд обновлять показания с датчика pH, прикреплённого к меге
#define PH_DEFAULT_CALIBRATION 0 // поправочное число по умолчанию, в сотых долях (т.е. 1 - это 0,01 сотая, 10 - это 0,1 и т.п.)
#define PH_DEFAULT_TARGET 700 // желаемое значение pH раствора на выходе, по умолчанию, целое число (700 = 7.00, 651 = 6.51 и т.п.)

// значение гистерезиса по умолчанию, в сотых долях (50 = 0.5, 100 = 1.0, 123 = 1.23 и т.п.). 
// Если pH раствора находится в рамках гистерезиса - корректировки pH не происходит.
#define PH_DEFAULT_HISTERESIS 50 // гистерезис

#define PH_DEFAULT_MIX_PUMP_TIME 60 // время работы насоса перемешивания по умолчанию, после каждой корректировки pH, секунд
#define PH_DEFAULT_REAGENT_PUMP_TIME 2 // время работы подачи реагента по умолчанию, для изменения pH на 0.1, секунд

#define PH_MV_PER_7_PH 2000 // кол-во милливольт, при  которых датчик показывает 7 pH

// раскомментировать следующую инструкцию #define, если датчик pH имеет реверсивное изменение вольтажа при изменении pH,
// т.е. если при увеличении pH значение вольтажа в порту контроллера уменьшается. По умолчанию считается, что при увеличении pH
// значение вольтажа в порту контроллера увеличивается.
// #define PH_REVERSIVE_MEASURE 

#define PH_CONTROL_CHECK_INTERVAL 10000 // через сколько миллисекунд контролировать значение pH на предмет попадания в эталонный диапазон

#define PH_FLOW_LEVEL_SENSOR_CHANNEL 0 // номер канала микросхемы PCF8574, на который заведён сигнал с датчика уровня воды
#define PH_FLOW_LEVEL_TRIGGERED HIGH // уровень, при котором датчик уровня воды считается сработавшим

#define PH_FLOW_ADD_CHANNEL 1 // номер канала микросхемы PCF8574 для включения клапана подачи воды
#define PH_FLOW_ADD_OFF LOW // уровень, при котором клапан подачи воды выключен
#define PH_FLOW_ADD_ON HIGH // уровень, при котором клапан подачи воды включен

#define PH_PLUS_CHANNEL 2 // номер канала микросхемы PCF8574 для повышения уровня pH
#define PH_MINUS_CHANNEL 3 // номер канала микросхемы PCF8574 для понижения уровня pH
#define PH_CONTROL_VALVE_ON HIGH // уровень, включающий клапан поправочного раствора
#define PH_CONTROL_VALVE_OFF LOW // уровень, выключающий клапан поправочного раствора

#define PH_MIX_PUMP_CHANNEL 4 // номер канала микросхемы PCF8574 для насоса перемешивания раствора
#define PH_MIX_PUMP_ON HIGH // уровень для включения насоса перемешивания раствора
#define PH_MIX_PUMP_OFF LOW // уровень для выключения насоса перемешивания раствора

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля датчиков влажности почвы (актуально при раскомментированной команде USE_SOIL_MOISTURE_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define SUPPORTED_SOIL_MOISTURE_SENSORS 1 // кол-во проводных датчиков влажности почвы

// ДЛЯ ПЛАТЫ ВЫВОДЫ ДАТЧИКОВ ВЛАЖНОСТИ ПОЧВЫ - A2, A3 
#define SOIL_MOISTURE_SENSORS {A2, FREQUENCY_SOIL_MOISTURE}//,{A3, ANALOG_SOIL_MOISTURE} // АНАЛОГОВЫЕ пины, на которых сидят датчики влажности почвы (через запятую, кол-во равно SUPPORTED_SOIL_MOISTURE_SENSORS!)

#define SOIL_MOISTURE_UPDATE_INTERVAL 10000 // через сколько мс обновлять показания с датчиков влажности почвы
#define SOIL_MOISTURE_100_PERCENT 450 // какие показания analogRead соответствуют датчику, погруженному в воду
#define SOIL_MOISTURE_0_PERCENT 1023 // какие показания analogRead соответствуют датчику на воздухе, т.е. полностью сухой почве 

// раскомментировать, если нужно управлять питанием датчиков влажности почвы.
// при раскомментированной настройке датчики перед опросом включаются,
// после опроса - выключаются.
//#define USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT

// сколько миллисекунд ждать перед подачей питания до чтения с датчиков
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_POWER_ON_DELAY 200 

// режимы управления пином питания датчиков влажности почвы - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_POWER_DRIVE_MODE DRIVE_DIRECT // прямое управление пинами, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим питанием датчиков (если управление в режиме DRIVE_MCP23S17)
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_MCP23S17_ADDRESS 1

// адрес микросхемы MCP23017, через которую рулим каналами досветки (если управление в режиме DRIVE_MCP23017)
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_MCP23017_ADDRESS 0 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// пин управления питанием датчиков влажности почвы (или номер канала MCP*, если управление 
// в режимах, отличных от DRIVE_DIRECT)
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_POWER_PIN 34

// уровни для управления питанием датчиков
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_POWER_ON LOW // уровень для включения питания датчиков
#define SOIL_MOISTURE_POWER_OFF HIGH // уровень для выключения питания датчиков


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля влажности (актуально при раскомментированной команде USE_HUMIDITY_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// типы поддерживаемых сенсоров: DHT11, DHT2x, SI7021, SHT10
#define SUPPORTED_HUMIDITY_SENSORS 2 // кол-во поддерживаемых проводных датчиков влажности
// описание поддерживаемых датчиков влажности, через запятую, кол-вом SUPPORTED_HUMIDITY_SENSORS.
// формат: H_SENSOR(пин1, пин2, тип)
// где: пин1 - первый пин, на котором висит датчик
// пин2 - второй пин, на котором висит датчик.
// в случае I2C-датчика:
//    1. Если используется только один датчик - значения обоих пинов - 0;
//    2. Если хотите использовать несколько датчиков (например, Si7021), но датчик поддерживает только один адрес на шине I2C,
//       то можно рвать линию строба (SCL), для этого в качестве первого пина указываете номер пина, на котором будет рваться строб
//       путём подачи на этот пин нужного уровня. Например, можно рвать стробы при помощи 74HC125.
//  пример для двух датчиков si7021:
//  H_SENSOR(10,0,SI7021), H_SENSOR(11,0,SI7021) - два датчика на шине I2C, управляем стробом первого через пин 10, второго - через пин 11

#define STROBE_OFF_LEVEL HIGH // уровень для разрыва строба датчика
#define STROBE_ON_LEVEL LOW // уровень для включения строба датчика

// в случае датчика, использующего одну линию (например, DHT*) - первый пин - линия данных, второй пин - 0
// два пина используются только SHT10: первый пин - данные (data pin), второй - строб (clock pin)
// следующий после первого датчик добавляется через запятую.
// Примеры:
// для одного датчика:
// #define HUMIDITY_SENSORS H_SENSOR(12,0,DHT2x)
// для двух и более датчиков:
// #define HUMIDITY_SENSORS H_SENSOR(12,0,DHT2x), H_SENSOR(14,0,DHT11), H_SENSOR(15,0,DHT2x)
// ДЛЯ ПЛАТЫ НОМЕРА ВЫВОДОВ ДЛЯ ДВУХ DHT - A6,A7 !!!
#define HUMIDITY_SENSORS H_SENSOR(0,0,SI7021), H_SENSOR(A7,0,DHT2x)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля температур/управления фрамугами (актуально при раскомментированной команде USE_TEMP_SENSORS)
//--------------------------------------------------------------------------------------------------------------------------------
#define DEF_OPEN_INTERVAL 30000 // по умолчанию 30 секунд работы мотора на полное открытие/закрытие фрамуги
#define DEF_OPEN_TEMP 25 // температура открытия по умолчанию, градусов Цельсия
#define DEF_CLOSE_TEMP 24 // температура закрытия по умолчанию, градусов Цельсия
#define SUPPORTED_SENSORS 1 // кол-во поддерживаемых проводных датчиков температуры, подсоединённых к контроллеру

// поддерживаемые типы датчиков температуры: DS18B20 и DS18S20
// для добавления датчика температуры используйте конструкцию ADD_T,
// например, ADD_T(22,DS18S20) добавляет датчик типа DS18S20 на 22-й пин
// ДЛЯ ПЛАТЫ ВЫВОДЫ ПО УМОЛЧАНИЮ, ПОДТЯНУТЫЕ РЕЗИСТОРАМИ - A11, A12, A13
#define TEMP_SENSORS_PINS ADD_T(A11,DS18B20)//, ADD_T(32,DS18B20) // пины, на которых висят наши датчики температуры (указываются через запятую, общее кол-во равно SUPPORTED_SENSORS)

#define SUPPORTED_WINDOWS 4 // кол-во поддерживаемых окон, максимум 16 (по два реле на мотор, для 8-ми канального модуля реле - 4 окна)
// пины реле управления фрамугами (попарно, через запятую!) На каждом пине висит одно реле, пара реле (например,
// 40 и 41) образуют одну пару управления DC-мотором. Кол-во реле равно SUPPORTED_WINDOWS*2, соответственно, кол-во используемых
// пинов - всегда чётно! Поэтому будьте внимательны при редактировании этой настройки!
// Как подключается мотор: контакты двигателя подключаются к общим (COM) контактам пары реле.
// Плюс питания - к NO (нормально разомкнутым контактам пары реле).
// Минус питания - к NC (нормально замкнутым контактам реле).

//--------------------------------------------------------------------------------------------------------------------------------
// Настройки пинов управления фрамугами (актуально при раскомментированной команде USE_TEMP_SENSORS)
//--------------------------------------------------------------------------------------------------------------------------------
// если USE_WINDOWS_SHIFT_REGISTER не определена (закомментирована выше) - через эти пины будут управляться реле
// КОЛ-ВО ПИНОВ РАВНО SUPPORTED_WINDOWS*2 !!! БУДЬТЕ ВНИМАТЕЛЬНЫ !!!
// ниже указан пример для управления четырьмя окнами напрямую, т.е. - 8 пинов
#define WINDOWS_RELAYS_PINS 40,41,42,43,44,45,46,47 

// Если USE_WINDOWS_SHIFT_REGISTER определена (раскомментирована выше) - управление окнами пойдёт через сдвиговый регистр 74HC595 по пинам, указанным ниже
#define WINDOWS_SHIFT_LATCH_PIN 40 // пин защёлки (нога ST_CP регистра)
#define WINDOWS_SHIFT_DATA_PIN 41 // пин данных (нога DS регистра)
#define WINDOWS_SHIFT_CLOCK_PIN  42 // пин тактирования (нога SH_CP регистра)
#define WINDOWS_SHIFT_OE_PIN 43 // пин, который управляет ногой OE регистра (должен быть подтянут к питанию резистором на 10К) 

//--------------------------------------------------------------------------------------------------------------------------------
// настройки концевиков для окон. Для каждого окна - два концевика, на открытие и закрытие.
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_WINDOWS_ENDSTOPS // закомментировать, если не нужно использовать концевики для окон

// режимы опроса концевиков - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
// по умолчанию - опрос пинов концевиков через MCP23S17 (DRIVE_DIRECT - прямое чтение пинов контроллера,
// DRIVE_MCP23017 - опрос через MCP23017)  
#define WINDOWS_ENDSTOPS_DRIVE_MODE DRIVE_MCP23S17 

// адрес микросхемы MCP23S17, через которую опрашиваем концевики открытия (если управление в режиме DRIVE_MCP23S17)
#define WINDOWS_ENDSTOPS_OPEN_MCP23S17_ADDRESS 3

// адрес микросхемы MCP23017, через которую опрашиваем концевики открытия (если управление в режиме DRIVE_MCP23017)
#define WINDOWS_ENDSTOPS_OPEN_MCP23017_ADDRESS 3 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// адрес микросхемы MCP23S17, через которую опрашиваем концевики закрытия (если управление в режиме DRIVE_MCP23S17)
#define WINDOWS_ENDSTOPS_CLOSE_MCP23S17_ADDRESS 4

// адрес микросхемы MCP23017, через которую опрашиваем концевики закрытия (если управление в режиме DRIVE_MCP23017)
#define WINDOWS_ENDSTOPS_CLOSE_MCP23017_ADDRESS 4 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// объявляем пины для опроса концевиков открытия - дописывать в этот массив, через запятую,
// кол-во равно SUPPORTED_WINDOWS! Первый концевик - соответствует первому окну и т.п.
// При прямом управлении пинами (DRIVE_DIRECT) - номера пинов, при управлении через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define WINDOWS_ENDSTOPS_OPEN_PINS 0,1,2,3 

// объявляем пины для опроса концевиков закрытия - дописывать в этот массив, через запятую,
// кол-во равно SUPPORTED_WINDOWS! Первый концевик - соответствует первому окну и т.п.
// При прямом управлении пинами (DRIVE_DIRECT) - номера пинов, при управлении через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define WINDOWS_ENDSTOPS_CLOSE_PINS 0,1,2,3

// уровень срабатывания концевика
#define WINDOWS_ENDSTOP_TRIGGERED_LEVEL LOW // по умолчанию - низкий уровень при срабатывании, сменить на HIGH, если концевик срабатывает по высокому

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления поливом (актуально при раскомментированной команде USE_WATERING_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// режимы управления пинами - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_DRIVE_MODE DRIVE_DIRECT // прямое управление пинами, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим каналами полива (если управление в режиме DRIVE_MCP23S17)
#define WATER_MCP23S17_ADDRESS 0

// адрес микросхемы MCP23017, через которую рулим каналами полива (если управление в режиме DRIVE_MCP23017)
#define WATER_MCP23017_ADDRESS 4 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// как управляем пином насоса (актуально при раскомментированной команде USE_PUMP_RELAY)
// режимы управления пинами -  [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_PUMP_DRIVE_MODE DRIVE_DIRECT // прямое управление пином, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23S17)
#define WATER_PUMP_MCP23S17_ADDRESS 0

// адрес микросхемы MCP23017, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23017)
#define WATER_PUMP_MCP23017_ADDRESS 4 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// пин, на котором сидит реле управления насосом:
// 1. Для прямого управления пинами (DRIVE_DIRECT - номер пина)
// 2. Для управления через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define PUMP_RELAY_PIN 22

// настройки второго насоса (актуально при раскомментированной команде USE_SECOND_PUMP)
// как управляем пином второго насоса
// режимы управления пинами - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_PUMP2_DRIVE_MODE DRIVE_DIRECT // прямое управление пином, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23S17)
#define WATER_PUMP2_MCP23S17_ADDRESS 0

// адрес микросхемы MCP23017, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23017)
#define WATER_PUMP2_MCP23017_ADDRESS 4 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// пин, на котором висит второй насос:
// 1. Для прямого управления пинами (DRIVE_DIRECT - номер пина)
// 2. Для управления через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define SECOND_PUMP_RELAY_PIN 22

 // с какого канала полива включать второй насос. Если используем второй насос, то можно первый насос включать
 // для первой половины каналов, второй насос - для второй половины каналов.
 // Например, если кол-во каналов - 4, и в этой настройке указано 2, то
 // для каналов 2 и больше (т.е. 2 и 3, нумерация каналов идёт с нуля) - будет включаться второй насос
 #define SECOND_PUMP_START_CHANNEL 2

// уровни для реле каналов полива
#define WATER_RELAY_ON LOW // уровень для включения реле
#define WATER_RELAY_OFF HIGH // уровень для выключения реле

// уровни для реле насоса
#define WATER_PUMP_RELAY_ON LOW // уровень для включения реле
#define WATER_PUMP_RELAY_OFF HIGH // уровень для выключения реле

#define WATER_RELAYS_COUNT 4 // сколько каналов управления поливом используется (максимум - 16)

// объявляем пины для управления каналами реле - дописывать в этот массив, через запятую,
// кол-во равно WATER_RELAYS_COUNT!
// ДЛЯ ПЛАТЫ НОМЕРА ВЫВОДОВ КОНТРОЛЯ КАНАЛОВ ПОЛИВА - 23,24,25,27
// При прямом управлении пинами - номера пинов, при управлении через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define WATER_RELAYS_PINS 23,24,25,27 

// интервал сохранений времени полива на каналах (чтобы сохранять не только в конце полива, но и в промежутках,
// например, каждую минуту), в минутах
#define WATERING_STATUS_SAVE_INTERVAL 2 // каждые 2 минуты сохранять время полива на канале за сегодня 

// закомментировать, если не надо переходить в автоматический режим работы
// по наступлению полуночи (контроллер переводит полив в автоматический режим,
// даже если полив был включен вручную пользователем - это сделано во избежание
// забывчивости и бесконтрольного полива)
 #define SWITCH_TO_AUTOMATIC_WATERING_MODE_AFTER_MIDNIGHT

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля LCD 128х64 на базе контроллера ST7920 (актуально при раскомментированной команде USE_LCD_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// определяем пины, на которых сидит экран
// подключение:
// пин BLA дисплея идёт на пин управления подсветкой
// пин BLK дисплея идёт на GND
// пин PSB дисплея идёт на GND
// пины GND и VCC дисплея - тут всё ясно
// пин E дисплея идёт на SCREEN_SCK_PIN (программный SPI), или - на хардварный SCK пин микроконтроллера (аппаратный SPI)
// пин R/W дисплея идёт на SCREEN_MOSI_PIN (программный SPI), или - на хардварный MOSI микроконтроллера (аппаратный SPI)
// пин RS дисплея - идёт на SCREEN_CS_PIN, это линия chip select, для выбора ведомого

//#define SCREEN_USE_SOFT_SPI // раскомментировать, если нужен режим программного SPI
#define SCREEN_SCK_PIN 52 // пин SCK, актуален для режима программного SPI (в режиме железного SPI используются соответствующий пин SCK микроконтроллера)
#define SCREEN_MOSI_PIN 51 // пин MOSI, актуален для режима программного SPI (в режиме железного SPI используются соответствующий пин MOSI микроконтроллера)
#define SCREEN_CS_PIN 4 // пин CS
#define SCREEN_BACKLIGHT_PIN 5 // номер пина, на котором будет управление подсветкой (пин с ШИМ !!!)
#define SCREEN_BACKLIGHT_INTENSITY 120 // яркость подсветки (0-255), управляется ШИМ на соответствующем пине (SCREEN_BACKLIGHT_PIN)
#define SCREEN_BACKLIGHT_OFF_DELAY 15000 // через сколько мс выключать подсветку дисплея после перехода в экран ожидания
#define MENU_RESET_DELAY 8000 // через сколько мс, если ничего не сделано, переключаться в экран ожидания
//#define FLIP_SCREEN // повернуть ли экран на 180 градусов при старте (закомментировать, если этого не надо)
//#define SCREEN_HINT_AT_RIGHT //раcкомментировать, если надо выравнивать подсказку выбранного экрана по правой стороне

#define WATER_CHANNELS_SCREEN_ENABLED // закомментировать, если не нужен экран управления отдельными каналами полива
#define WINDOWS_CHANNELS_SCREEN_ENABLED  // закомментировать, если не нужен экран управления отдельными каналами окон
#define SENSORS_SETTINGS_ON_SD_ENABLED // закомментировать, если не нужно читать настройки датчиков экрана ожидания с SD-карты
/*
 Принцип простой: если SENSORS_SETTINGS_ON_SD_ENABLED раскомментирована и на SD-карте есть настройки датчиков - мы читаем и выводим с них,
 в противном случае - деградируем на вшитые настройки WAIT_SCREEN_SENSORS, которые описаны ниже
 */

// настройки кнопки для меню
#define MENU_BUTTON_PIN A10 // пин, на котором висит кнопка перехода внутрь экрана и выбора между параметрами
// кнопка подключается так:
// пин подтянут к питанию резистором на 10К - и соединён с кнопкой
// второй контакт кнопки - к земле. Керамика - желательна.

// настройки энкодера
// энкодер подключается так: средний вывод - к питанию.
// левый и правый - к пинам, дополнительно притянуты к земле резисторами на 10К
#define ENCODER_A_PIN A0 // пин МК, на котором сигнал с левой ноги энкодера
#define ENCODER_B_PIN A1 // пин МК, на котором сигнал с правой ноги энкодера
#define ENCODER_PULSES_PER_CLICK 20 // сколько импульсов приходится на один клик энкодера, подбирать опытным путём, для удобства

// настройки экрана ожидания
#define ROTATION_INTERVAL 7000 // через сколько мс менять на экране ожидания показания с датчиков
// на экране ожидания можно выводить N показаний любых поддерживаемых системой датчиков.
// для добавления показаний с датчика используйте конструкцию W_S.
// показания добавляются в WAIT_SCREEN_SENSORS, через запятую, например:
// добавляем на экран ожидания показания температурного датчика с индексом 0
// модуля STATE:  W_S(StateTemperature,0,"STATE","Tнаруж")
// Пример для нескольких датчиков:
// #define WAIT_SCREEN_SENSORS W_S(StateTemperature,0,"STATE","Твнутр") ,W_S(StateTemperature,1,"STATE","Tнаруж") ,W_S(StateLuminosity,0,"LIGHT","свет") ,W_S(StateHumidity,0,"HUMIDITY","влажность")
// типы показаний: StateTemperature - температура, StateLuminosity - освещенность, StateHumidity - влажность, StateSoilMoisture - влажность почвы, StatePH - значение pH

// определяем вид экрана ожидания тут
#define WAIT_SCREEN_SENSORS W_S(StateSoilMoisture,0,"SOIL","Почва"), W_S(StateSoilMoisture,1,"SOIL","Почва модуль"), W_S(StateTemperature,0,"STATE","T внутри") ,W_S(StateHumidity,0,"HUMIDITY","Влажность") ,W_S(StateLuminosity,0,"LIGHT","Освещенность")


//--------------------------------------------------------------------------------------------------------------------------------
// Настройки W5100 (актуально при раскомментированной команде USE_W5100_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define W5100_REBOOT_PIN 44 // номер пина, на котором будет управление питанием W5100 - пока реализовано только включение (актуально при раскомментированной команде USE_W5100_REBOOT_PIN)
#define W5100_POWER_OFF LOW // уровень для выключения питания
#define W5100_POWER_ON HIGH // уровень для включения питания

//--------------------------------------------------------------------------------------------------------------------------------
// Настройки Nextion (актуально при раскомментированной команде USE_NEXTION_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define NEXTION_SERIAL Serial3 // какой Serial используем для Nextion (ВНИМАНИЕ! Если используется RS-485 - Nextion по умолчанию сидит на этом же Serial, конфликт!)
#define NEXTION_BAUD_RATE 9600 // скорость обмена командами с дисплеем
#define NEXTION_SLEEP_DELAY 60 // через сколько секунд переходить в сон, если ничего не сделано на экране
#define NEXTION_WAIT_TIMER 10000 // интервал таймера переключения на экран ожидания, мс
#define NEXTION_ROTATION_INTERVAL 7000 // через сколько мс менять на экране ожидания показания с датчиков

// настройки экрана ожидания
// на экране ожидания можно выводить N показаний любых поддерживаемых системой датчиков.
// для добавления показаний с датчика используйте конструкцию NW_S.
// показания добавляются в NEXTION_WAIT_SCREEN_SENSORS, через запятую, например:
// добавляем на экран ожидания показания температурного датчика с индексом 0
// модуля STATE:  NW_S(StateTemperature,0,"STATE")
// Пример для нескольких датчиков:
// #define NEXTION_WAIT_SCREEN_SENSORS NW_S(StateTemperature,0,"STATE") ,NW_S(StateTemperature,1,"STATE") ,NW_S(StateLuminosity,0,"LIGHT") ,NW_S(StateHumidity,0,"HUMIDITY")
// типы показаний: StateTemperature - температура, StateLuminosity - освещенность, StateHumidity - влажность.
// На текущий момент Nextion подддерживает вывод только этих типов датчиков, поскольку выводит подписи к типу датчика картинками,
// следовательно - надо менять файл проекта для Nextion. Если вы читаете эти строки и вам необходима такое усовершенствование - 
// дайте мне знать, и я постараюсь добавить этот функционал.

// определяем вид экрана ожидания тут
#define NEXTION_WAIT_SCREEN_SENSORS NW_S(StateTemperature,0,"STATE") ,NW_S(StateHumidity,1,"HUMIDITY") ,NW_S(StateLuminosity,0,"LIGHT")

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля учёта воды (актуально при раскомментированной команде USE_WATERFLOW_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// модуль занимает пины 2 и 3 меги, т.к. работает по прерываниям. Для Due юзаются пины 11 и 12.
// поддерживаемые типы датчиков - китайские water flow meter с датчиком Холла.
// подключение простое: питание, земля, линию данных - на пин FIRST_WATERFLOW_PIN для первого датчика, на пин SECOND_WATERFLOW_PIN - для второго датчика.

#define FIRST_WATERFLOW_PIN 2 // пин для первого расходомера
#define SECOND_WATERFLOW_PIN 3 // пин для второго расходомера 

#define WATERFLOW_SENSORS_COUNT 2 // доступные значения: 0, 1, 2. Если 0 - никакие показания сниматься не будут, следовательно, пины FIRST_WATERFLOW_PIN и SECOND_WATERFLOW_PIN останутся свободны
#define WATERFLOW_SAVE_DELTA 10 // через сколько накопленных литров сохранять в EEPROM значение с датчика

// сколько пульсаций в секунду выдаёт датчик при протекании литра за минуту - 
// калибровочное значение, если не совпадает с реальным расходом - подбирать!
#define WATERFLOW_CALIBRATION_FACTOR 45 // фактор калибровки по умолчанию, можно потом менять через конфигуратор

#define WATERFLOW_CHECK_FREQUENCY 2000 // через сколько мс обновлять показания с датчиков расхода


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления по SMS (модем SIM800) (актуально при раскомментированной команде USE_SMS_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define GSM_SERIAL Serial1 // какой хардварный Serial будем использовать при работе с модемом?
#define GSM_BAUDRATE 57600 // скорость работы с GSM-модемом
#define GSM_AVAILABLE_CHECK_TIME 60000 // через сколько миллисекунд проверять доступность модема посылкой команды AT
#define GSM_WAIT_BOOT_TIME 2000 // сколько мс ждать загрузки модема
#define GSM_CHECK_REGISTRATION_INTERVAL 4567 // через сколько мс проверять регистрацию в сети (повторные вызовы с указанным промежутком до тех пор, пока модем не зарегистрируется)
#define GSM_REBOOT_TIME 2000 // сколько миллисекунд держать питание выключенным при перезагрузке модема, если он завис
#define GSM_WAIT_AFTER_REBOOT_TIME 5000 // сколько мс ждать после перезагрузки модема прежде, чем начать обрабатывать команды
#define GSM_MAX_ANSWER_TIME 60000 // через сколько мс, если не получен ответ на команду от модема, считать его зависшим
#define GSM_REBOOT_PIN 12 // номер пина, на котором будет управление питанием GSM-модема (актуально при раскомментированной команде USE_GSM_REBOOT_PIN)
#define GSM_POWER_OFF LOW // уровень для выключения питания
#define GSM_POWER_ON HIGH // уровень для включения питания

#define GSM_PULL_GPRS_BY_PING // закомментировать, если не надо периодически пинговать выбранный хост (нужно, чтобы поддерживать GPRS-соединение при очень редких запросах в сеть)
#define GSM_PING_INTERVAL 45000 // интервал в миллисекундах для пинга
#define GSM_PING_HOST F("ya.ru") // хост, который пингуем

// раскомментировать, если нужно управление подачей питания на SIM800 (вход POWERKEY)
// при этом на нужный выход МК подаётся импульс нужного уровня нужной длительности
// для включения модема в работу
//#define USE_SIM800_POWERKEY 
#define SIM800_POWERKEY_PIN 67 // номер пина, на котором будет импульс для включения модема в работу
#define SIM800_POWERKEY_PULSE_DURATION 300 // сколько миллисекунд держать импульс
#define SIM800_POWERKEY_OFF_LEVEL HIGH // начальный уровень на выходе POWERKEY
#define SIM800_POWERKEY_ON_LEVEL LOW // уровень, который держится нужное кол-во времени
#define SIM800_WAIT_POWERKEY_AFTER_POWER_ON 500 // сколько миллисекунд ждать после подачи питания до подачи импульса POWERKEY

#define SEND_WINDOW_STATE_IN_STATUS_SMS // закомментировать, если не надо посылать статус окон в СМС статистики
#define SEND_WATER_STATE_IN_STATUS_SMS // закомментировать, если не надо посылать статус полива в СМС статистики

// настройки датчиков для СМС статистики по умолчанию (если нет SD-карты или там ничего не сохранено)
// индексы модулей:
// 1 - модуль температур
// 2 - модуль влажности
// 3 - модуль освещённости
// 4 - модуль влажности почвы

#define STATUS_SMS_DEFAULT_MODULE1 1 // модуль для первого датчика
#define STATUS_SMS_DEFAULT_SENSOR1 0 // индекс датчика в первом модуле
#define STATUS_SMS_DEFAULT_LABEL1 F("Твнутр") // подпись по умолчанию для первого датчика

#define STATUS_SMS_DEFAULT_MODULE2 1 // модуль для второго датчика
#define STATUS_SMS_DEFAULT_SENSOR2 1 // индекс датчика во втором модуле
#define STATUS_SMS_DEFAULT_LABEL2 F("Тнаруж") // подпись по умолчанию для второго датчика

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля WI-FI (актуально при раскомментированной команде USE_WIFI_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// ПРОШИВКА ДЛЯ ESP НАХОДИТСЯ В ПАПКЕ ESP_AT - РАБОТОСПОСОБНОСТЬ ПРОВЕРЕНА ТОЛЬКО В СВЯЗКЕ С ЭТОЙ ПРОШИВКОЙ!!!
// ИНСТРУКЦИИ ПО ПРОШИВКЕ НАХОДЯТСЯ В ТОЙ ЖЕ ПАПКЕ, В ФАЙЛЕ README.TXT!!!
// НАСТОЯТЕЛЬНО РЕКОМЕНДУЕТСЯ ИСПОЛЬЗОВАТЬ ПИН УПРАВЛЕНИЕ ПИТАНИЕМ ДЛЯ ПОЛНОГО ПЕРЕСБРОСА ESP!!!
//--------------------------------------------------------------------------------------------------------------------------------
#define WIFI_SERIAL Serial2 // какой хардварный сериал использовать для WI-FI?
#define WIFI_BAUDRATE 57600 // скорость работы с UART для WI-FI
#define STATION_ID F("TEPLICA") // ID точки доступа, которую создаёт модуль WI-FI
#define STATION_PASSWORD F("12345678") // пароль к точке доступа, которую создаёт вай-фай (МИНИМУМ 8 СИМВОЛОВ, ИНАЧЕН НЕ БУДЕТ РАБОТАТЬ!)
#define ROUTER_ID F("")  // SSID домашнего роутера, к которому коннектится модуль WI-FI
#define ROUTER_PASSWORD F("") // пароль к домашнему роутеру, к которому коннектится модуль WI-FI

#define WIFI_AVAILABLE_CHECK_TIME 60000 // через сколько миллисекунд проверять доступность ESP посылкой команды AT
#define WIFI_REBOOT_TIME 2000 // сколько миллисекунд держать питание выключенным при перезагрузке ESP, если он завис
#define WIFI_WAIT_BOOT_TIME 2000 // сколько мс ждать загрузки модема
#define WIFI_WAIT_AFTER_REBOOT_TIME 5000 // сколько мс ждать после перезагрузки ESP прежде, чем начать обрабатывать команды
#define WIFI_MAX_ANSWER_TIME 60000 // через сколько мс, если не получен ответ на команду от модема, считать его зависшим
#define WIFI_IPD_READING_TIMEOUT 1000 // таймаут на чтение входящих данных от ESP, миллисекунд (+IPD)
#define WIFI_REBOOT_PIN 11 // номер пина, на котором будет управление питанием GSM-модема (актуально при раскомментированной команде USE_WIFI_REBOOT_PIN)
#define WIFI_POWER_OFF LOW // уровень для выключения питания
#define WIFI_POWER_ON HIGH // уровень для включения питания

//--------------------------------------------------------------------------------------------------------------------------------
// настройки тревог (актуально при раскомментированной команде USE_ALARM_DISPATCHER)
//--------------------------------------------------------------------------------------------------------------------------------
#define ALARM_SMS_TEXT F("Тревога! Сработало правило: ") // текст СМС, который отправится при срабатывании тевожного правила, к СМС будет добавлено имя правила
//#define CLEAR_ALARM_STATUS // раскомментировать, если надо очищать сработавшие тревоги через указанный ниже промежуток времени. 
//Если тревоги не очищаются - SMS посылается однократно, до перезагрузки контроллера
#define ALARM_CLEAR_INTERVAL 10 // интервал между очистками сработавших тревог, в минутах


#endif
