#ifndef _CONFIGURATION_DUE_H
#define _CONFIGURATION_DUE_H

#if (TARGET_BOARD != DUE_BOARD)
  #error "Target board MUST BE DUE_BOARD for this configuration!"
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// USER SETTINGS
// ПОЛЬЗОВАТЕЛЬСКИЕ НАСТРОЙКИ
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------------------------------------------------
// директивы условной компиляции:
/*
    в общем случае для предварительной настройки прошивки достаточно закомментировать ту или иную директиву USE_*.
    конкретные настройки пинов и пр. - находятся после директив условной компиляции, и подхватываются только тогда,
    когда соответствующая директива USE_* определена.
 */
//--------------------------------------------------------------------------------------------------------------------------------
// скорость работы I2C
#define I2C_SPEED 400000UL // 400кГц, поменять на 100000UL для скорости 100кГц
//--------------------------------------------------------------------------------------------------------------------------------
// uncomment this line if you need to measure temperatures in Fahrenheit instead of Celsius
// раскомментируйте эту настройку, если вам надо измерять температуру не в градусах Цельсия, а в Фаренгейтах
//#define MEASURE_TEMPERATURES_IN_FAHRENHEIT 
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не хотим использовать модуль реального времени (DS3231)
// без этого модуля многий функционал не работает, например, логгирование информации или работа модуля полива по расписанию.
// можно считать, что использование этого модуля - обязательно.
// start this line with comment, if you don't want to use DS3231 realtime clock (not recommended, this device used by some modules)
#define USE_DS3231_REALTIME_CLOCK
#define DS3231_WIRE_NUMBER 0 // номер I2C для часов (0 - первый I2C, 1 - второй I2C)
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужен модуль управления пинами
// этот модуль косвенно используют другие модули (например, модуль составных команд) для управления пинами
// start this line with comment, if you don't want to use PIN module (drive pins by using commands like CTSET=PIN|13|ON etc.) 
#define USE_PIN_MODULE 
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужно управление окнами по температуре
// start this line with comment, if you don't want to use STATE module (drive windows and holds temperature from DS18*20 sensors)
#define USE_TEMP_SENSORS
//--------------------------------------------------------------------------------------------------------------------------------
// использовать ли сдвиговый регистр 74HC595 для управления окнами, вместо контроля пинов напрямую (см. настройки фрамуг ниже)
// start this line with comment, if you don't want to use 74HC595 shift register to drive the windows, and  want the direct drive trough pins. See settings below.
#define USE_WINDOWS_SHIFT_REGISTER
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужна поддержка модуля статистики (FREERAM, UPTIME, DATETIME)
// start this line with comment, if you don't want to use STAT module (FREERAM, UPTIME, DATETIME commands)
#define USE_STAT_MODULE
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужна поддержка управления по SMS (SIM800)
// start this line with comment, if you don't want to use GSM module (SIM800)
#define USE_SMS_MODULE 
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужен модуль управления поливом (в принципе, тот же функционал можно реализовать через правила)
// start this line with comment, if you don't want to use watering module
#define USE_WATERING_MODULE 
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужен модуль контроля освещенности (BH17500 и MAX44009)
// start this line with comment, if you don't want to use luminosity module (BH17500 and MAX44009 sensors)
#define USE_LUMINOSITY_MODULE 
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_HUMIDITY_MODULE // закомментировать, если не нужен модуль работы с датчиками влажности DHT, Si7021, SHT
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_SOIL_MOISTURE_MODULE // закомментировать, если не нужен модуль датчиков влажности почвы
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_PH_MODULE // закомментировать, если не нужен модуль снятия показаний с датчиков pH и контроля за дозированием реагентов в систему
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_LOG_MODULE // закомментировать, если не нужен модуль логгирования информации. Внимание: модуль работает только с модулем реального времени (USE_DS3231_REALTIME_CLOCK должна быть определена!)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_DELTA_MODULE // закомментировать, если не нужно собирать показания дельт с датчиков (разница показаний между двумя датчиками)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WATERFLOW_MODULE // закомментировать, если не нужны датчик(и) расхода воды (пин(ы) 2 (и 3) меги), настройки - см. ниже
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_COMPOSITE_COMMANDS_MODULE // закомментировать, если не нужен модуль составных команд (позволяет выполнить скопом несколько разных действий, используется правилами)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_RESERVATION_MODULE // закомментировать, если не нужем модуль резервирования датчиков (когда при отсутствии показаний с одного датчика показания берутся со связанных с ним).
// модуль резервирования нужен для работы правил, если необходимо обеспечить работу правила даже тогда, когда один из датчиков вышел из строя
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_TIMER_MODULE // закомментировать, если не нужна поддержка модуля таймеров (4 таймера)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_IOT_MODULE // закомментировать, если не нужна отсылка данных на IoT-хранилища (ThingSpeak). Настройки IoT смотрите ниже
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_ALARM_DISPATCHER // закомментировать, если не нужны тревоги (получение СМС при срабатывании правила)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании ESP (если ESP долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_GSM_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании модема (если GSM-модем долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_NRF_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании nRF (если nRF долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_LORA_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании LoRa (если LoRa долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_W5100_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании W5100 (если W5100 долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_EXTERNAL_WATCHDOG // закомментировать, если не нужен внешний контроль зависания меги (мега на определённой ноге дёргает уровни, если уровни не меняются - внешний ватчдог передёргивает питание)
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать ESP как один из шлюзов для отсыла данных в IoT
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE_AS_HTTP_PROVIDER // закомментировать, если не хотим посылать HTTP-запросы к сервису gardenboss.ru через ESP
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE_AS_MQTT_CLIENT // раскомментировать, если хотим использовать ESP как MQTT-клиент
//--------------------------------------------------------------------------------------------------------------------------------
#define MQTT_REPORT_AS_JSON // раскомментировать, если надо публиковать топик-ответ на выполнение команды в объекте JSON
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_GSM_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать GSM-модем как один из шлюзов для отсыла данных в IoT
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_GSM_MODULE_AS_HTTP_PROVIDER // закомментировать, если не хотим посылать HTTP-запросы к сервису gardenboss.ru через GSM
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужно использовать никакие универсальные модули (если эта директива закомментирована - модули любых типов не используются),
// если раскомментирована - используются модули с датчиками на борту, исполнительные модули - используются в зависимости от настройки USE_UNI_EXECUTION_MODULE).
// если эта строка закомментирована - никакие из модулей использоваться не будут
#define USE_UNIVERSAL_MODULES
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не надо использовать выносной модуль на 7 кнопок с привязками к командам (прошивка UniversalControlModule)
#define USE_RS485_EXTERNAL_CONTROL_MODULE
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_UNI_EXECUTION_MODULE // закомментировать, если не нужна поддержка универсальных исполнительных модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_UNI_REGISTRATION_LINE // закомментировать, если не нужна проводная линия 1-Wire для регистрации универсальных модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_RS485_GATE // закомментировать, если не нужна поддержка опроса универсальных модулей по протоколу RS-485
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_NRF_GATE // закомментировать, если не нужно работать с универсальными модулями по радиоканалу nRF
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_LORA_GATE // закомментировать, если не нужно работать с универсальными модулями по радиоканалу LoRa (чипы SX1276/77/78/79)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_PUMP_RELAY // закомментировать, если не нужен отдельный канал управления насосом при поливе (настройки - ниже)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_SECOND_PUMP // использовать ли второй насос для полива (настройки - ниже). Директива USE_PUMP_RELAY при использовании второго насоса также должна быть определена!
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_HTTP_MODULE // закомментировать, если не нужна проверка на входящие команды и отсыл данных на сервис gardenboss.ru
//--------------------------------------------------------------------------------------------------------------------------------
// расширители портов
//--------------------------------------------------------------------------------------------------------------------------------

// использовать или нет расширители портов MCP23S17, при этом модули, которые поддерживают работу через эти расширители, могут работать через них. 
// Настройки расширителя на SPI смотрите ниже.
#define USE_MCP23S17_EXTENDER // раскомментировать, если хотите использовать MCP23S17 (работу через них поддерживает модуль полива и модуль досветки)

// использовать или нет расширители портов MCP23017, при этом модули, которые поддерживают работу через эти расширители, могут работать через них. 
// Настройки расширителя на I2C смотрите ниже.
//#define USE_MCP23017_EXTENDER // раскомментировать, если хотите использовать MCP23017 (работу через них поддерживает модуль полива и модуль досветки)

//--------------------------------------------------------------------------------------------------------------------------------
// шлюзы (ИСПОЛЬЗОВАТЬ ВМЕСТЕ НЕ ДОПУСКАЕТСЯ, прошивка не скомпилируется!)
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужна поддержка управления через Wi-Fi (ESP8266) (не работает совместно с USE_W5100_MODULE!)
// порт, на котором ESP слушает входящие команды в режиме точки доступа - 1975.
// ПРОШИВКА ДЛЯ ESP НАХОДИТСЯ В ПАПКЕ ESP_AT - РАБОТОСПОСОБНОСТЬ ПРОВЕРЕНА ТОЛЬКО В СВЯЗКЕ С ЭТОЙ ПРОШИВКОЙ!!!
// ИНСТРУКЦИИ ПО ПРОШИВКЕ НАХОДЯТСЯ В ТОЙ ЖЕ ПАПКЕ, В ФАЙЛЕ README.TXT!!!
// НАСТОЯТЕЛЬНО РЕКОМЕНДУЕТСЯ ИСПОЛЬЗОВАТЬ ПИН УПРАВЛЕНИЕ ПИТАНИЕМ ДЛЯ ПОЛНОГО ПЕРЕСБРОСА ESP!!!
#define USE_WIFI_MODULE

// закомментировать, если не нужна работа по Ethernet через W5100 (не работает совместно с USE_WIFI_MODULE!)
// для W5100 реализован только простейший мост TCP-контроллер, т.е. через W5100 можно общаться с контроллером
// любыми понятными ему командами. Порт для W5100 - 1975.
//#define USE_W5100_MODULE

//--------------------------------------------------------------------------------------------------------------------------------
// экраны (ИСПОЛЬЗОВАТЬ ВМЕСТЕ НЕ ДОПУСКАЕТСЯ, прошивка не скомпилируется!)
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_LCD_MODULE // закомментировать, если не нужен дисплей 128х64 на базе контроллера ST7920
//#define USE_NEXTION_MODULE // закомментировать, если не нужна поддержка Nextion
#define USE_TFT_MODULE // закомментировать, если не нужна поддержка 7'' TFT на контроллере SSD1963 с разрешением 800x480
//--------------------------------------------------------------------------------------------------------------------------------
// информационные диоды
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_READY_DIODE // закомментировать, если не нужен диод, горящий при работе контроллера (пин номер DIODE_READY_PIN)
#define BLINK_READY_DIODE // закомментировать, если не нужно периодически мигать диодом работы
#define USE_WINDOWS_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления фрамугами (пин DIODE_WINDOWS_MANUAL_MODE_PIN)
#define USE_WATERING_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления поливом (пин DIODE_WATERING_MANUAL_MODE_PIN)
#define USE_LIGHT_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления досветкой (пин DIODE_LIGHT_MANUAL_MODE_PIN)

//--------------------------------------------------------------------------------------------------------------------------------
// менеджер обратной связи для окон (универсальный модуль, который отдаёт информацию о положении окон и срабатывании концевиков)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_FEEDBACK_MANAGER // закомментировать, если не нужно использовать модуль обратной связи по положению окон
// (прошивка UniversalExecutionModule с включенной обратной связью)
#define FEEDBACK_MANAGER_WAIT_TIME 15000 // если в течение указанного кол-ва миллисекунд после старта контроллера не придёт информация
// по положению окон - окна принудительно погонятся контроллером в закрытую позицию, чтобы обеспечить начальную точку отсчёта
#define FEEDBACK_MANAGER_UPDATE_INTERVAL 5000 // через сколько миллисекунд запрашивать информацию у модулей обратной связи
#define FEEDBACK_MANAGER_POSITION_HISTERESIS 500 // кол-во миллисекунд работы моторов, которое следует игнорировать, если текущая позиция окон
// находится в рамках этого гистерезиса, т.е. разница текущей позиции и запрошенной - меньше гистерезиса
//--------------------------------------------------------------------------------------------------------------------------------
/*
 ниже идут конкретные настройки того или иного функционала.
 */
//--------------------------------------------------------------------------------------------------------------------------------
// настройки расширителей портов MCP23S17 (актуально при раскомментированной команде USE_MCP23S17_EXTENDER)
//--------------------------------------------------------------------------------------------------------------------------------
#define MCP23S17_CS_PIN 46 // номер пина chip select для микросхем MCP23S17
#define COUNT_OF_MCP23S17_EXTENDERS 6 // сколько расширителей портов MCP23S17 используется (0 - нисколько)
#define MCP23S17_ADDRESSES 1, 2, 3, 4, 5, 6 // адреса расширителей MCP23S17, через запятую, кол-вом COUNT_OF_MCP23S17_EXTENDERS

//--------------------------------------------------------------------------------------------------------------------------------
// настройки расширителей портов MCP23017 (актуально при раскомментированной команде USE_MCP23017_EXTENDER)
//--------------------------------------------------------------------------------------------------------------------------------
#define COUNT_OF_MCP23017_EXTENDERS 0 // сколько расширителей портов MCP23017 используется (0 - нисколько)
// адреса расширителей MCP23017, через запятую, кол-вом COUNT_OF_MCP23017_EXTENDERS
// 0 - первый адрес 0x20, 1 - второй адрес 0x21 и т.п.
#define MCP23017_ADDRESSES 4,5 

//--------------------------------------------------------------------------------------------------------------------------------
// НАСТРОЙКИ ВНЕШНЕГО ВАТЧДОГА (актуально при раскомментированной команде USE_EXTERNAL_WATCHDOG)
//--------------------------------------------------------------------------------------------------------------------------------
#define WATCHDOG_REBOOT_PIN 66 // номер пина, на котором будут меняться уровни
#define WATCHDOG_NORMAL_LEVEL LOW // уровень на ноге, который держится WATCHDOG_WORK_INTERVAL миллисекунд
#define WATCHDOG_TRIGGERED_LEVEL HIGH // уровень импульса на ноге, который держится WATCHDOG_PULSE_DURATION миллисекунд
#define WATCHDOG_WORK_INTERVAL 5000 // через сколько миллисекунд на ноге будет уровень WATCHDOG_TRIGGERED_LEVEL
#define WATCHDOG_PULSE_DURATION 200 // сколько миллисекунд держать уровень WATCHDOG_TRIGGERED_LEVEL на ноге

//--------------------------------------------------------------------------------------------------------------------------------
// НАСТРОЙКИ УНИВЕРСАЛЬНЫХ МОДУЛЕЙ (актуально при раскомментированной команде USE_UNIVERSAL_MODULES)
//--------------------------------------------------------------------------------------------------------------------------------
#define UNI_REGISTRATION_PIN 49 // номер пина, на котором будут регистрироваться модули в системе (актуально при раскомментированной команде USE_UNI_REGISTRATION_LINE)
#define UNI_MODULE_UPDATE_INTERVAL 2000 // через сколько мс обновлять показания с универсального модуля
#define UNI_WIRED_MODULES_COUNT 0 // сколько проводных линий для универсальных модулей используется (0 - нисколько)
#define UNI_WIRED_MODULES 57 // номера пинов (через запятую), на которых висят универсальные модули, кол-вом  UNI_WIRED_MODULES_COUNT

//--------------------------------------------------------------------------------------------------------------------------------
// настройки RS-485 (актуально при раскомментированной команде USE_RS485_GATE)
//--------------------------------------------------------------------------------------------------------------------------------
#define RS_485_SERIAL Serial3 // ВНИМАНИЕ! СЛЕДИТЕ ЗА ОТСУТСТВИЕМ КОНФЛИКТОВ С SERIAL. ЭТОТ ЖЕ SERIAL ИСПОЛЬЗУЕТСЯ Nextion, т.е. либо Nextion по Serial, либо - RS-485!!!
/*
// НЕ ИСПОЛЬЗУЮТСЯ
#define RS_485_UCSR USART3 // регистр, связанный с номером UART RS_485_SERIAL
#define RS_485_TXC US_CSR_TXEMPTY // бит ТХ, связанный с номером UART RS_485_SERIAL
*/
#define RS_485_DE_PIN 68 // номер пина, на котором будет происходить переключение приёма/передачи по RS-485
#define RS485_STATE_PUSH_FREQUENCY 1000 // через сколько миллисекунд писать в шину RS-485 слепок состояния контроллера
#define RS485_ONE_SENSOR_UPDATE_INTERVAL 1234 // через сколько миллисекунд запрашивать с шины RS-485 показания одного датчика (полный цикл опроса будет равен интервалу*кол-во датчиков в системе)
#define RS485_BYTES_TIMEOUT 10 // кол-во байт, после неуспешной попытки вычитки которых принимать решение о таймауте (если данные по RS-485 не ходят - увеличьте это значение).
#define RS485_RESET_SENSOR_AFTER_N_BAD_READINGS 5 // через сколько неудачных чтений с датчика сбрасывать его значения на вид "<нет данных>"
//--------------------------------------------------------------------------------------------------------------------------------
// настройки nRF (актуально при раскомментированной команде USE_NRF_GATE)
//--------------------------------------------------------------------------------------------------------------------------------
#define UNI_DEFAULT_RF_CHANNEL 19 // номер канала для nRF по умолчанию
#define NRF_CE_PIN 47 // номер пина CE для модуля nRF
#define NRF_CSN_PIN 48 // номер пина CSN для модуля nRF
#define NRF_CONTROLLER_STATE_CHECK_FREQUENCY 789 // через сколько миллисекунд проверять смену состояния контроллера (для отсылки в эфир при изменениях)
// номер пина для пересброса питания nRF (в текущей версии управление питанием не реализовано - на этот пин для платы просто подаётся нужный уровень)
#define NRF_REBOOT_PIN 60 // (актуально при раскомментированной команде USE_NRF_REBOOT_PIN) 
#define NRF_POWER_ON LOW
#define NRF_POWER_OFF HIGH
//#define NRF_AUTOACK_INVERTED // раскомментировать эту строчку здесь и в прошивках универсальных модулей, если у вас они не коннектятся. 
// Иногда auto aсk в китайских модулях имеет инвертированное значение.
//--------------------------------------------------------------------------------------------------------------------------------
// настройки LoRa (актуально при раскомментированной команде USE_LORA_GATE)
//--------------------------------------------------------------------------------------------------------------------------------
#define LORA_SS_PIN 48 // пин SS для LoRa
#define LORA_RESET_PIN 47 // пин Reset для LoRa
#define LORA_FREQUENCY 433E6 // частота работы (433E6, 866E6, 915E6)
#define LORA_TX_POWER 17 // мощность передатчика (1 - 17)
#define LORA_CONTROLLER_STATE_CHECK_FREQUENCY 789 // через сколько миллисекунд проверять смену состояния контроллера (для отсылки в эфир при изменениях)
// номер пина для пересброса питания LoRa (в текущей версии управление питанием не реализовано - на этот пин для платы просто подаётся нужный уровень)
#define LORA_REBOOT_PIN 60 // (актуально при раскомментированной команде USE_LORA_REBOOT_PIN) 
#define LORA_POWER_ON LOW
#define LORA_POWER_OFF HIGH
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля периодических таймеров, 4 штуки (актуально при раскомментированной команде USE_TIMER_MODULE) 
//--------------------------------------------------------------------------------------------------------------------------------
#define TIMER_ON HIGH // уровень, который надо выставлять на пине, когда таймер включён
#define TIMER_OFF LOW // уровень, который надо выставлять на пине, когда таймер выключён

//--------------------------------------------------------------------------------------------------------------------------------
// настройки EEPROM для хранения данных
//--------------------------------------------------------------------------------------------------------------------------------
// тут определяем, какую память мы используем
//--------------------------------------------------------------------------------------------------------------------------------
#define EEPROM_USED_MEMORY EEPROM_AT24C128 // используем внешнюю память I2C AT24C128 (типы памяти см. в Configaration_Shared.h)
// если используется внешнняя память AT24C* - то ниже определяется индекс микросхемы. Например, китайский модуль часов реального времени
// с DS3231 на борту имеет модуль памяти с адресом на шине I2C 0x57, т.е. индекс такого модуля - 7, т.к. базовый адрес памяти на шине - 
// 0x50. Настройкой ниже можно указать адрес микросхемы памяти на шине I2C.
#define EEPROM_MEMORY_INDEX 0
//--------------------------------------------------------------------------------------------------------------------------------
#define SETT_HEADER1 0x1F // байты, сигнализирующие о наличии сохранённых настроек, первый
#define SETT_HEADER2 0xBF // и второй

//--------------------------------------------------------------------------------------------------------------------------------
// адреса хранения данных в EEPROM (МИНИМАЛЬНЫЙ ОБЪЁМ EEPROM - 4 Кб !!!)
//--------------------------------------------------------------------------------------------------------------------------------

#define CONTROLLER_ID_EEPROM_ADDR 1 // по какому адресу располагается ID контроллера, 1 байт
#define UNI_SENSOR_INDICIES_EEPROM_ADDR 2 // с какого адреса идут выданные индексы для универсальных сенсоров, 10 байт

#define WIFI_STATE_EEPROM_ADDR 12// адрес хранения состояния Wi-Fi (коннектится к роутеру или нет), 1 байт
#define STATION_PASSWORD_EEPROM_ADDR 13// адрес хранения пароля к точке ESP, 20 байт
#define STATION_ID_EEPROM_ADDR 33// адрес хранения ID точки доступа ESP, 20 байт
#define ROUTER_PASSWORD_EEPROM_ADDR 53// адрес хранения пароля к роутеру, 20 байт
#define ROUTER_ID_EEPROM_ADDR 73// адрес хранение ID роутера, 20 байт

#define SMS_NUMBER_EEPROM_ADDR 93 // адрес хранения номера телефона хозяина, 15 байт
#define GSM_PROVIDER_EEPROM_ADDR 108 // адрес хранения оператора GSM, 1 байт

#define IOT_SETTINGS_EEPROM_ADDR 109 // адрес хранения настроек IOT, 51 байт
#define OPEN_INTERVAL_EEPROM_ADDR 160 // адрес хранения настроек интервала открытия окон, 4 байта
#define CLOSE_TEMP_EEPROM_ADDR 164 // адрес хранения температуры закрытия, 1 байт
#define OPEN_TEMP_EEPROM_ADDR 165 // адрес хранения температуры открытия, 1 байт

#define WATERING_OPTION_EEPROM_ADDR 166 // адрес хранения текущей опции полива, 1 байт
#define TURN_PUMP_EEPROM_ADDR 167 // адрес хранения флага - включить ли насос при поливе, 1 байт
#define START_WATERING_TIME_EEPROM_ADDR 168 // адрес хранения начала полива для всех каналов, 2 байта
#define WATERING_TIME_EEPROM_ADDR 170 // адрес хранения продолжительности полива для всех каналов, 2 байта
#define WATERING_WEEKDAYS_EEPROM_ADDR 172 // адрес хранения маски дней недели полива на всех каналах, 1 байт
#define WATERING_SENSOR_EEPROM_ADDR 173 // адрес хранения индекса датчика в модуле влажности почв, показания с которого учитываются при поливе, 1 байт
#define WATERING_STOP_BORDER_EEPROM_ADDR 174 // адрес хранения показаний с датчика, по которым полив на всех каналах выключается, 1 байт
#define WATERING_CHANNELS_SETTINGS_EEPROM_ADDR 175 // адрес начала настроек каналов полива, 16 каналов*7 байт на канал - 112 байт
#define WATERING_STATUS_EEPROM_ADDR 300 // с какого адреса у нас идут статусы каналов полива, по 5 байт на канал, 100 байт


#define WATERFLOW_EEPROM_ADDR 400 // с какого адреса у нас будут записываться показания датчиков расхода воды, 12 байт

#define DELTA_SETTINGS_EEPROM_ADDR 412 // с какого адреса в EEPROM начинаются настройки дельт, 500 байт на 20 дельт
#define PH_SETTINGS_EEPROM_ADDR 912 // с какого адреса идут настройки PH-модуля, 30 байт
#define TIMERS_EEPROM_ADDR 942 // у нас 4 таймера, на каждый - 10 байт + заголовок (2 байта), итого - 42 байта 
#define RESERVATION_ADDR 984 // адрес, с которого пишутся настройки резервирования (10 списков по 12 байт + 3 байта = 123 байта)
#define GUID_ADDRESS 1110 // адрес, по которому хранится уникальный GUID контроллера (32 символа без пробелов + 2 байта - заголовок присутствия - 34 байта)
#define HTTP_API_KEY_ADDRESS 1144 // адрес, ко которому хранится ключ доступа к HTTP API (32 символа без пробелов + 2 байта - заголовок присутствия + 1 байт - флаг активности, вкл/выкл) - 35 байт
#define HTTP_SEND_SENSORS_DATA_ADDRESS 1179 // адрес хранения флага - отсылать ли слепок показаний датчиков контроллера при проверке задач по HTTP, 1 байт
#define TIMEZONE_ADDRESS 1180 // адрес хранения часового пояса контроллера, 4 байта (2 байта заголовок присутствия, 2 байта - таймзона). Хранится в минутах
#define HTTP_SEND_STATUS_ADDRESS 1184 // адрес хранения флага - отсылать ли слепок состояния контроллера при проверке задач по HTTP, 1 байт

#define MQTT_ENABLED_FLAG_ADDRESS 1185 // адрес хранения флага - активен ли MQTT-клиент, 1 байт
#define MQTT_INTERVAL_BETWEEN_TOPICS_ADDRESS 1186 // адрес хранения интервала (в секундах) между публикацией топиков в брокер MQTT, 1 байт


#define COMPOSITE_COMMANDS_START_ADDR 3248 // с четвёртого килобайта в EEPROM идут составные команды

#define EEPROM_RULES_START_ADDR 5120 // с пятого килобайта в EEPROM идут правила

//--------------------------------------------------------------------------------------------------------------------------------
// настройки Serial
//--------------------------------------------------------------------------------------------------------------------------------
#define SERIAL_BAUD_RATE 57600 // скорость работы с портами, бод (конфигуратор работает с портом именно на скорости 57600)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки информационных диодов 
//--------------------------------------------------------------------------------------------------------------------------------
// как рулим информационными диодами [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define INFO_DIODES_DRIVE_MODE DRIVE_MCP23S17 // по умолчанию - прямое управление
// адрес микросхемы MCP23S17, через которую рулим информационными диодами (если управление в режиме DRIVE_MCP23S17)
#define INFO_DIODES_MCP23S17_ADDRESS 6
// адрес микросхемы MCP23017, через которую рулим информационными диодами (если управление в режиме DRIVE_MCP23017)
#define INFO_DIODES_MCP23017_ADDRESS 0 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.
//--------------------------------------------------------------------------------------------------------------------------------
#define DIODE_READY_PIN 0 // пин или номер канала расширителя портов, на котором висит диод индикации работы (актуально при раскомментированной команде USE_READY_DIODE)
#define DIODE_WINDOWS_MANUAL_MODE_PIN 1 // пин или номер канала расширителя портов, на котором будет диод, мигающий, когда мы в ручном режиме управления окнами (актуально при раскомментированной команде USE_WINDOWS_MANUAL_MODE_DIODE)
#define DIODE_WATERING_MANUAL_MODE_PIN 2 // пин или номер канала расширителя портов, на котором висит диод индикации ручного режима управления поливом (актуально при раскомментированной команде USE_WATERING_MANUAL_MODE_DIODE)
#define DIODE_LIGHT_MANUAL_MODE_PIN 3 // пин или номер канала расширителя портов, на котором висит диод индикации ручного режима управления досветкой (актуально при раскомментированной команде USE_LIGHT_MANUAL_MODE_DIODE)

// интервалы мигания
#define WORK_MODE_BLINK_INTERVAL 500 // с какой частотой мигать на пинах индикации ручного режима работы, мс
#define READY_DIODE_BLINK_INTERVAL 5000 // с какой частотой мигать диодом работы, мс

//--------------------------------------------------------------------------------------------------------------------------------
// настройки SD и нумерации виртуальных пинов
//--------------------------------------------------------------------------------------------------------------------------------
#define SDCARD_CS_PIN 52 // номер пина Chip Select для SD-модуля 
#define VIRTUAL_PIN_START_NUMBER 80 // номер пина, с которого все пины будут считаться виртуальными, т.е. запись в них производиться не будет, однако в карте пинов (16 байт) этот статус будет отражён.

//--------------------------------------------------------------------------------------------------------------------------------
// настройки железных модулей реле 
//--------------------------------------------------------------------------------------------------------------------------------
#define RELAY_ON LOW // уровень для включения реле фрамуг
#define RELAY_OFF HIGH // уровень для выключения реле фрамуг
#define SHORT_CIRQUIT_STATE HIGH // статус пинов, на которых висит реле фрамуг, чтобы закоротить мотор и не дать ему крутиться

//--------------------------------------------------------------------------------------------------------------------------------
// настройки максимумов
//--------------------------------------------------------------------------------------------------------------------------------
#define MAX_ALERT_RULES 50 // максимальное кол-во поддерживаемых правил
#define MAX_DELTAS 20 // максимальное кол-во дельт. Внимание: на 20 дельт нужно примерно 500 байт в EEPROM, следите за непересечением адресов!!!

//--------------------------------------------------------------------------------------------------------------------------------
// настройки интервалов обновлений модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define ALERT_UPDATE_INTERVAL 500 // интервал обновления состояния модуля ALERT, мс. Нужен, чтобы часто не разрешать зависимости - это ресурсоёмкая операция.
//#define ALERT_INCLUDE_COMMA_VALUES // раскомментировать, если в правилах надо сравнивать не только целую часть показаний, но и дробную
#define LOGGING_INTERVAL 300000 // интервал логгирования, мс (300000 - каждые 5 минут и т.п.)
#define LUMINOSITY_UPDATE_INTERVAL 3000 // через сколько мс обновлять показания с датчиков освещенности 
#define HUMIDITY_UPDATE_INTERVAL 5000 // через сколько мс обновлять показания с датчиков влажности
#define TEMP_UPDATE_INTERVAL 4990 // через сколько мс обновлять показания с датчиков температуры
#define DELTA_UPDATE_INTERVAL 5010 // через сколько миллисекунд обновлять показания дельт?

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля освещенности (BH1750, MAX44009) (актуально при раскомментированной команде USE_LUMINOSITY_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// режимы управления пинами - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define LIGHT_DRIVE_MODE DRIVE_MCP23S17 // прямое управление пинами, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим каналами досветки (если управление в режиме DRIVE_MCP23S17)
#define LIGHT_MCP23S17_ADDRESS 1

// адрес микросхемы MCP23017, через которую рулим каналами досветки (если управление в режиме DRIVE_MCP23017)
#define LIGHT_MCP23017_ADDRESS 0 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// уровни для реле каналов досветки
#define LIGHT_RELAY_ON LOW // уровень для включения реле
#define LIGHT_RELAY_OFF HIGH // уровень для выключения реле

// Поддерживается максимум 4 датчика - два BH1750 и два - MAX44009
#define LIGHT_SENSORS_COUNT 1 // кол-во проводных датчиков освещенности на шине I2C, 0-4
#define LIGHT_SENSORS BH1750_SENSOR //, MAX44009_SENSOR // типы датчиков, через запятую (для BH1750 - пишем BH1750_SENSOR, для MAX44009 - пишем MAX44009_SENSOR)
// количество записей должно быть равно LIGHT_SENSORS_COUNT !!!
// первый датчик любого типа имеет первый адрес датчика на шине I2C, второй упомянутый - следующий адрес на шине. Например,
// если записать BH1750_SENSOR, BH1750_SENSOR - то это значит, что подключены два датчика BH1750, и у первого - будет первый адрес, у второго - второй.

#define LAMP_RELAYS_COUNT 8 // кол-во реле для управления досветкой, максимум - 8 каналов

// пины, на которых сидят реле управления досветкой (через запятую, кол-во равно LAMP_RELAYS_COUNT!)
// в случае управления через расширители портов (DRIVE_MCP23S17, DRIVE_MCP23017) - номера каналов микросхемы 
#define LAMP_RELAYS_PINS 0,1,2,3,4,5,6,7

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля контроля pH (РАБОТАЕТ ЧЕРЕЗ МИКРОСХЕМУ PCF8574T на шине I2C !!!) (актуально при раскомментированной команде USE_PH_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
/*
 Принцип работы модуля контроля pH:
 
   1. Все каналы заведены через микросхему PCF8574T, которую можно подсоединить как прямо к меге, 
      так и вытащить через удлинитель I2C;
      
   2. К одному из каналов подключен датчик понижения уровня жидкости в ёмкости с рабочим раствором, 
      который при срабатывании выдаёт сигнал определённого уровня;
      
   3. При срабатывании датчика уровня начинается пополнение ёмкости с рабочим раствором, для этого на канал, 
      к которому подключен клапан подачи воды - подаётся определённый уровень;
      
   4. Как только ёмкость заполнена - начинается контроль pH;
   
   5. При отклонении pH от нужных значений, в зависимости от направления отклонения - 
      на каналы клапанов для повышения/понижения значения pH подаётся нужный уровень;
      
   6. После подачи корректировочного раствора в нужном объёме на канал управление насосом, 
      перемешивающим рабочий раствор, подаётся нужный уровень;
      
   7. После окончания перемешивания система продолжает контролировать pH, периодически при необходимости 
      повторяя вышеописанные действия, чтобы добиться требуемого уровня pH.
   
 */
//--------------------------------------------------------------------------------------------------------------------------------
#define PCF8574_ADDRESS 0x27 // адрес микросхемы для контроля pH на шине I2C (0x20 - 0x27)
#define PH_SENSOR_PIN 0 // номер аналогового пина, с которого читать показания датчика (0 - нет датчика, прикреплённого к меге)
#define PH_SAMPLES_PER_MEASURE 10 // сколько делать замеров на одно измерение pH (1-255)
#define PH_SAMPLES_INTERVAL 20 // сколько миллисекунд между замерами в одном цикле измерения делать (10 - 255)
#define PH_UPDATE_INTERVAL 15678 // через сколько миллисекунд обновлять показания с датчика pH, прикреплённого к меге
#define PH_DEFAULT_CALIBRATION 0 // поправочное число по умолчанию, в сотых долях (т.е. 1 - это 0,01 сотая, 10 - это 0,1 и т.п.)
#define PH_DEFAULT_TARGET 700 // желаемое значение pH раствора на выходе, по умолчанию, целое число (700 = 7.00, 651 = 6.51 и т.п.)

// значение гистерезиса по умолчанию, в сотых долях (50 = 0.5, 100 = 1.0, 123 = 1.23 и т.п.). 
// Если pH раствора находится в рамках гистерезиса - корректировки pH не происходит.
#define PH_DEFAULT_HISTERESIS 50 // гистерезис

#define PH_DEFAULT_MIX_PUMP_TIME 60 // время работы насоса перемешивания по умолчанию, после каждой корректировки pH, секунд
#define PH_DEFAULT_REAGENT_PUMP_TIME 2 // время работы подачи реагента по умолчанию, для изменения pH на 0.1, секунд

#define PH_MV_PER_7_PH 2000 // кол-во милливольт, при  которых датчик показывает 7 pH

// раскомментировать следующую инструкцию #define, если датчик pH имеет реверсивное изменение вольтажа при изменении pH,
// т.е. если при увеличении pH значение вольтажа в порту контроллера уменьшается. По умолчанию считается, что при увеличении pH
// значение вольтажа в порту контроллера увеличивается.
// #define PH_REVERSIVE_MEASURE 

#define PH_CONTROL_CHECK_INTERVAL 10000 // через сколько миллисекунд контролировать значение pH на предмет попадания в эталонный диапазон

#define PH_FLOW_LEVEL_SENSOR_CHANNEL 0 // номер канала микросхемы PCF8574, на который заведён сигнал с датчика уровня воды
#define PH_FLOW_LEVEL_TRIGGERED HIGH // уровень, при котором датчик уровня воды считается сработавшим

#define PH_FLOW_ADD_CHANNEL 1 // номер канала микросхемы PCF8574 для включения клапана подачи воды
#define PH_FLOW_ADD_OFF LOW // уровень, при котором клапан подачи воды выключен
#define PH_FLOW_ADD_ON HIGH // уровень, при котором клапан подачи воды включен

#define PH_PLUS_CHANNEL 2 // номер канала микросхемы PCF8574 для повышения уровня pH
#define PH_MINUS_CHANNEL 3 // номер канала микросхемы PCF8574 для понижения уровня pH
#define PH_CONTROL_VALVE_ON HIGH // уровень, включающий клапан поправочного раствора
#define PH_CONTROL_VALVE_OFF LOW // уровень, выключающий клапан поправочного раствора

#define PH_MIX_PUMP_CHANNEL 4 // номер канала микросхемы PCF8574 для насоса перемешивания раствора
#define PH_MIX_PUMP_ON HIGH // уровень для включения насоса перемешивания раствора
#define PH_MIX_PUMP_OFF LOW // уровень для выключения насоса перемешивания раствора

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля датчиков влажности почвы (актуально при раскомментированной команде USE_SOIL_MOISTURE_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define SUPPORTED_SOIL_MOISTURE_SENSORS 1 // кол-во проводных датчиков влажности почвы

#define SOIL_MOISTURE_SENSORS {A4, ANALOG_SOIL_MOISTURE}//,{A2, FREQUENCY_SOIL_MOISTURE} // АНАЛОГОВЫЕ пины, на которых сидят датчики влажности почвы (через запятую, кол-во равно SUPPORTED_SOIL_MOISTURE_SENSORS!)

#define SOIL_MOISTURE_UPDATE_INTERVAL 10000 // через сколько мс обновлять показания с датчиков влажности почвы
#define SOIL_MOISTURE_100_PERCENT 450 // какие показания analogRead соответствуют датчику, погруженному в воду
#define SOIL_MOISTURE_0_PERCENT 1023 // какие показания analogRead соответствуют датчику на воздухе, т.е. полностью сухой почве 

// раскомментировать, если нужно управлять питанием датчиков влажности почвы.
// при раскомментированной настройке датчики перед опросом включаются,
// после опроса - выключаются.
//#define USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT

// сколько миллисекунд ждать перед подачей питания до чтения с датчиков
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_POWER_ON_DELAY 200 

// режимы управления пином питания датчиков влажности почвы - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_POWER_DRIVE_MODE DRIVE_DIRECT // прямое управление пинами, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим питанием датчиков (если управление в режиме DRIVE_MCP23S17)
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_MCP23S17_ADDRESS 1

// адрес микросхемы MCP23017, через которую рулим каналами досветки (если управление в режиме DRIVE_MCP23017)
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_MCP23017_ADDRESS 0 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// пин управления питанием датчиков влажности почвы (или номер канала MCP*, если управление 
// в режимах, отличных от DRIVE_DIRECT)
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_POWER_PIN 34

// уровни для управления питанием датчиков
// (настройка актуальна при раскомментированной USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT)
#define SOIL_MOISTURE_POWER_ON LOW // уровень для включения питания датчиков
#define SOIL_MOISTURE_POWER_OFF HIGH // уровень для выключения питания датчиков

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля влажности (актуально при раскомментированной команде USE_HUMIDITY_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// типы поддерживаемых сенсоров: DHT11, DHT2x, SI7021, SHT10
#define SUPPORTED_HUMIDITY_SENSORS 2 // кол-во поддерживаемых проводных датчиков влажности
// описание поддерживаемых датчиков влажности, через запятую, кол-вом SUPPORTED_HUMIDITY_SENSORS.
// формат: H_SENSOR(пин1, пин2, тип)
// где: пин1 - первый пин, на котором висит датчик
// пин2 - второй пин, на котором висит датчик.
// в случае I2C-датчика:
//    1. Если используется только один датчик - значения обоих пинов - 0;
//    2. Если хотите использовать несколько датчиков (например, Si7021), но датчик поддерживает только один адрес на шине I2C,
//       то можно рвать линию строба (SCL), для этого в качестве первого пина указываете номер пина, на котором будет рваться строб
//       путём подачи на этот пин нужного уровня. Например, можно рвать стробы при помощи 74HC125.
//  пример для двух датчиков si7021:
//  H_SENSOR(10,0,SI7021), H_SENSOR(11,0,SI7021) - два датчика на шине I2C, управляем стробом первого через пин 10, второго - через пин 11

#define STROBE_OFF_LEVEL HIGH // уровень для разрыва строба датчика
#define STROBE_ON_LEVEL LOW // уровень для включения строба датчика

// в случае датчика, использующего одну линию (например, DHT*) - первый пин - линия данных, второй пин - 0
// два пина используются только SHT10: первый пин - данные (data pin), второй - строб (clock pin)
// следующий после первого датчик добавляется через запятую.
// Примеры:
// для одного датчика:
// #define HUMIDITY_SENSORS H_SENSOR(12,0,DHT2x)
// для двух и более датчиков:
// #define HUMIDITY_SENSORS H_SENSOR(12,0,DHT2x), H_SENSOR(14,0,DHT11), H_SENSOR(15,0,DHT2x)
// ДЛЯ ПЛАТЫ НОМЕРА ВЫВОДОВ ДЛЯ ДВУХ DHT - A6,A7 !!!
#define HUMIDITY_SENSORS H_SENSOR(0,0,SI7021), H_SENSOR(50,0,DHT2x)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля температур/управления фрамугами (актуально при раскомментированной команде USE_TEMP_SENSORS)
//--------------------------------------------------------------------------------------------------------------------------------
#define DEF_OPEN_INTERVAL 30000 // по умолчанию 30 секунд работы мотора на полное открытие/закрытие фрамуги
#define DEF_OPEN_TEMP 25 // температура открытия по умолчанию, градусов Цельсия
#define DEF_CLOSE_TEMP 24 // температура закрытия по умолчанию, градусов Цельсия
#define SUPPORTED_SENSORS 3 // кол-во поддерживаемых проводных датчиков температуры, подсоединённых к контроллеру

// поддерживаемые типы датчиков температуры: DS18B20 и DS18S20
// для добавления датчика температуры используйте конструкцию ADD_T,
// например, ADD_T(22,DS18S20) добавляет датчик типа DS18S20 на 22-й пин
#define TEMP_SENSORS_PINS ADD_T(54,DS18B20), ADD_T(55,DS18B20), ADD_T(56,DS18B20) // пины, на которых висят наши датчики температуры (указываются через запятую, общее кол-во равно SUPPORTED_SENSORS)

#define SUPPORTED_WINDOWS 16 // кол-во поддерживаемых окон, максимум 16 (по два реле на мотор, для 8-ми канального модуля реле - 4 окна)
// пины реле управления фрамугами (попарно, через запятую!) На каждом пине висит одно реле, пара реле (например,
// 40 и 41) образуют одну пару управления DC-мотором. Кол-во реле равно SUPPORTED_WINDOWS*2, соответственно, кол-во используемых
// пинов - всегда чётно! Поэтому будьте внимательны при редактировании этой настройки!
// Как подключается мотор: контакты двигателя подключаются к общим (COM) контактам пары реле.
// Плюс питания - к NO (нормально разомкнутым контактам пары реле).
// Минус питания - к NC (нормально замкнутым контактам реле).

//--------------------------------------------------------------------------------------------------------------------------------
// Настройки пинов управления фрамугами (актуально при раскомментированной команде USE_TEMP_SENSORS)
//--------------------------------------------------------------------------------------------------------------------------------
// если USE_WINDOWS_SHIFT_REGISTER не определена (закомментирована выше) - через эти пины будут управляться реле
// КОЛ-ВО ПИНОВ РАВНО SUPPORTED_WINDOWS*2 !!! БУДЬТЕ ВНИМАТЕЛЬНЫ !!!
// ниже указан пример для управления четырьмя окнами напрямую, т.е. - 8 пинов
#define WINDOWS_RELAYS_PINS 40,41,42,43,44,45,46,47 

// Если USE_WINDOWS_SHIFT_REGISTER определена (раскомментирована выше) - управление окнами пойдёт через сдвиговый регистр 74HC595 по пинам, указанным ниже
#define WINDOWS_SHIFT_LATCH_PIN 42 // пин защёлки (нога ST_CP регистра)
#define WINDOWS_SHIFT_DATA_PIN 43 // пин данных (нога DS регистра)
#define WINDOWS_SHIFT_CLOCK_PIN  44 // пин тактирования (нога SH_CP регистра)
#define WINDOWS_SHIFT_OE_PIN 45 // пин, который управляет ногой OE регистра (должен быть подтянут к питанию резистором на 10К) 

//--------------------------------------------------------------------------------------------------------------------------------
// настройки концевиков для окон. Для каждого окна - два концевика, на открытие и закрытие.
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_WINDOWS_ENDSTOPS // закомментировать, если не нужно использовать концевики для окон

// режимы опроса концевиков - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
// по умолчанию - опрос пинов концевиков через MCP23S17 (DRIVE_DIRECT - прямое чтение пинов контроллера,
// DRIVE_MCP23017 - опрос через MCP23017)  
#define WINDOWS_ENDSTOPS_DRIVE_MODE DRIVE_MCP23S17 

// адрес микросхемы MCP23S17, через которую опрашиваем концевики открытия (если управление в режиме DRIVE_MCP23S17)
#define WINDOWS_ENDSTOPS_OPEN_MCP23S17_ADDRESS 3

// адрес микросхемы MCP23017, через которую опрашиваем концевики открытия (если управление в режиме DRIVE_MCP23017)
#define WINDOWS_ENDSTOPS_OPEN_MCP23017_ADDRESS 3 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// адрес микросхемы MCP23S17, через которую опрашиваем концевики закрытия (если управление в режиме DRIVE_MCP23S17)
#define WINDOWS_ENDSTOPS_CLOSE_MCP23S17_ADDRESS 4

// адрес микросхемы MCP23017, через которую опрашиваем концевики закрытия (если управление в режиме DRIVE_MCP23017)
#define WINDOWS_ENDSTOPS_CLOSE_MCP23017_ADDRESS 4 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// объявляем пины для опроса концевиков открытия - дописывать в этот массив, через запятую,
// кол-во равно SUPPORTED_WINDOWS! Первый концевик - соответствует первому окну и т.п.
// При прямом управлении пинами (DRIVE_DIRECT) - номера пинов, при управлении через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define WINDOWS_ENDSTOPS_OPEN_PINS 0,1,2,3 

// объявляем пины для опроса концевиков закрытия - дописывать в этот массив, через запятую,
// кол-во равно SUPPORTED_WINDOWS! Первый концевик - соответствует первому окну и т.п.
// При прямом управлении пинами (DRIVE_DIRECT) - номера пинов, при управлении через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define WINDOWS_ENDSTOPS_CLOSE_PINS 0,1,2,3

// уровень срабатывания концевика
#define WINDOWS_ENDSTOP_TRIGGERED_LEVEL LOW // по умолчанию - низкий уровень при срабатывании, сменить на HIGH, если концевик срабатывает по высокому


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления поливом (актуально при раскомментированной команде USE_WATERING_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// режимы управления пинами - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_DRIVE_MODE DRIVE_MCP23S17 // прямое управление пинами, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим каналами полива (если управление в режиме DRIVE_MCP23S17)
#define WATER_MCP23S17_ADDRESS 5

// адрес микросхемы MCP23017, через которую рулим каналами полива (если управление в режиме DRIVE_MCP23017)
#define WATER_MCP23017_ADDRESS 0 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// как управляем пином насоса (актуально при раскомментированной команде USE_PUMP_RELAY)
// режимы управления пинами -  [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_PUMP_DRIVE_MODE DRIVE_MCP23S17 // прямое управление пином, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23S17)
#define WATER_PUMP_MCP23S17_ADDRESS 5

// адрес микросхемы MCP23017, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23017)
#define WATER_PUMP_MCP23017_ADDRESS 0 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// пин, на котором сидит реле управления насосом:
// 1. Для прямого управления пинами (DRIVE_DIRECT - номер пина)
// 2. Для управления через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define PUMP_RELAY_PIN 7

// настройки второго насоса (актуально при раскомментированной команде USE_SECOND_PUMP)
// как управляем пином второго насоса
// режимы управления пинами - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_PUMP2_DRIVE_MODE DRIVE_MCP23S17 // прямое управление пином, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23S17)
#define WATER_PUMP2_MCP23S17_ADDRESS 5

// адрес микросхемы MCP23017, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23017)
#define WATER_PUMP2_MCP23017_ADDRESS 0 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// пин, на котором висит второй насос:
// 1. Для прямого управления пинами (DRIVE_DIRECT - номер пина)
// 2. Для управления через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define SECOND_PUMP_RELAY_PIN 15

 // с какого канала полива включать второй насос. Если используем второй насос, то можно первый насос включать
 // для первой половины каналов, второй насос - для второй половины каналов.
 // Например, если кол-во каналов - 4, и в этой настройке указано 2, то
 // для каналов 2 и больше (т.е. 2 и 3, нумерация каналов идёт с нуля) - будет включаться второй насос
 #define SECOND_PUMP_START_CHANNEL 7

// уровни для реле каналов полива
#define WATER_RELAY_ON LOW // уровень для включения реле
#define WATER_RELAY_OFF HIGH // уровень для выключения реле

// уровни для реле насоса
#define WATER_PUMP_RELAY_ON LOW // уровень для включения реле
#define WATER_PUMP_RELAY_OFF HIGH // уровень для выключения реле

#define WATER_RELAYS_COUNT 14 // сколько каналов управления поливом используется (максимум - 16)

// объявляем пины для управления каналами реле - дописывать в этот массив, через запятую,
// кол-во равно WATER_RELAYS_COUNT!
// При прямом управлении пинами - номера пинов, при управлении через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define WATER_RELAYS_PINS 0,1,2,3,4,5,6,8,9,10,11,12,13,14

// интервал сохранений времени полива на каналах (чтобы сохранять не только в конце полива, но и в промежутках,
// например, каждую минуту), в минутах
#define WATERING_STATUS_SAVE_INTERVAL 2 // каждые 2 минуты сохранять время полива на канале за сегодня

// закомментировать, если не надо переходить в автоматический режим работы
// по наступлению полуночи (контроллер переводит полив в автоматический режим,
// даже если полив был включен вручную пользователем - это сделано во избежание
// забывчивости и бесконтрольного полива)
 #define SWITCH_TO_AUTOMATIC_WATERING_MODE_AFTER_MIDNIGHT


//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Настройки пищалки
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// uncomment, if you want to use buzzer with touch on screen buttons
// раскомментировать, если надо использовать пищалку для звуков при нажатии кнопок на любом из поддерживаемых экранов
#define USE_BUZZER_ON_TOUCH 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// buzzer sound duration, ms
// сколько миллисекунд включать пищалку
#define BUZZER_DURATION 60 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// buzzer drive mode  [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
// как рулим пищалкой [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define BUZZER_DRIVE_MODE DRIVE_MCP23S17 // по умолчанию - управление через MCP23S17
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// MCP23S17 address to control the buzzer (if BUZZER_DRIVE_MODE == DRIVE_MCP23S17)
// адрес микросхемы MCP23S17, через которую рулим пищалкой (если управление в режиме DRIVE_MCP23S17)
#define BUZZER_MCP23S17_ADDRESS 6
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// MCP23017 address to control the buzzer (if BUZZER_DRIVE_MODE == DRIVE_MCP23017)
// 0 - first address 0x20, 1 - second address 0x21 etc.
// адрес микросхемы MCP23017, через которую рулим пищалкой (если управление в режиме DRIVE_MCP23017)
// 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.
#define BUZZER_MCP23017_ADDRESS 0 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// pin number or port extender channel number, connected with buzzer (actual with USE_BUZZER_ON_TOUCH defined)
// пин или номер канала расширителя портов, на котором висит пищалка (актуально при раскомментированной команде USE_BUZZER_ON_TOUCH)
#define BUZZER_DRIVE_PIN 7 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// buzzer OFF level
// уровень для выключения пищалки
#define BUZZER_OFF LOW 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// buzzer ON level
// уровень для включения пищалки
#define BUZZER_ON HIGH 

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля LCD 128х64 на базе контроллера ST7920 (актуально при раскомментированной команде USE_LCD_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// определяем пины, на которых сидит экран
// подключение:
// пин BLA дисплея идёт на пин управления подсветкой
// пин BLK дисплея идёт на GND
// пин PSB дисплея идёт на GND
// пины GND и VCC дисплея - тут всё ясно
// пин E дисплея идёт на SCREEN_SCK_PIN (программный SPI), или - на хардварный SCK пин микроконтроллера (аппаратный SPI)
// пин R/W дисплея идёт на SCREEN_MOSI_PIN (программный SPI), или - на хардварный MOSI микроконтроллера (аппаратный SPI)
// пин RS дисплея - идёт на SCREEN_CS_PIN, это линия chip select, для выбора ведомого

//#define SCREEN_USE_SOFT_SPI // раскомментировать, если нужен режим программного SPI
#define SCREEN_SCK_PIN 76 // пин SCK, актуален для режима программного SPI (в режиме железного SPI используются соответствующий пин SCK микроконтроллера)
#define SCREEN_MOSI_PIN 75 // пин MOSI, актуален для режима программного SPI (в режиме железного SPI используются соответствующий пин MOSI микроконтроллера)
#define SCREEN_CS_PIN 53 // пин CS
#define SCREEN_BACKLIGHT_PIN 7 // номер пина, на котором будет управление подсветкой (пин с ШИМ !!!)
#define SCREEN_BACKLIGHT_INTENSITY 120 // яркость подсветки (0-255), управляется ШИМ на соответствующем пине (SCREEN_BACKLIGHT_PIN)
#define SCREEN_BACKLIGHT_OFF_DELAY 15000 // через сколько мс выключать подсветку дисплея после перехода в экран ожидания
#define MENU_RESET_DELAY 8000 // через сколько мс, если ничего не сделано, переключаться в экран ожидания
//#define FLIP_SCREEN // повернуть ли экран на 180 градусов при старте (закомментировать, если этого не надо)
//#define SCREEN_HINT_AT_RIGHT //раcкомментировать, если надо выравнивать подсказку выбранного экрана по правой стороне

#define WATER_CHANNELS_SCREEN_ENABLED // закомментировать, если не нужен экран управления отдельными каналами полива
#define WINDOWS_CHANNELS_SCREEN_ENABLED  // закомментировать, если не нужен экран управления отдельными каналами окон
#define SENSORS_SETTINGS_ON_SD_ENABLED // закомментировать, если не нужно читать настройки датчиков экрана ожидания с SD-карты
/*
 Принцип простой: если SENSORS_SETTINGS_ON_SD_ENABLED раскомментирована и на SD-карте есть настройки датчиков - мы читаем и выводим с них,
 в противном случае - деградируем на вшитые настройки WAIT_SCREEN_SENSORS, которые описаны ниже
 */

// настройки кнопки для меню
#define MENU_BUTTON_PIN 64 // пин, на котором висит кнопка перехода внутрь экрана и выбора между параметрами
// кнопка подключается так:
// пин подтянут к питанию резистором на 10К - и соединён с кнопкой
// второй контакт кнопки - к земле. Керамика - желательна.

// настройки энкодера
// энкодер подключается так: средний вывод - к питанию.
// левый и правый - к пинам, дополнительно притянуты к земле резисторами на 10К
#define ENCODER_A_PIN 62 // пин МК, на котором сигнал с левой ноги энкодера
#define ENCODER_B_PIN 63 // пин МК, на котором сигнал с правой ноги энкодера
#define ENCODER_PULSES_PER_CLICK 20 // сколько импульсов приходится на один клик энкодера, подбирать опытным путём, для удобства

// настройки экрана ожидания
#define ROTATION_INTERVAL 7000 // через сколько мс менять на экране ожидания показания с датчиков
// на экране ожидания можно выводить N показаний любых поддерживаемых системой датчиков.
// для добавления показаний с датчика используйте конструкцию W_S.
// показания добавляются в WAIT_SCREEN_SENSORS, через запятую, например:
// добавляем на экран ожидания показания температурного датчика с индексом 0
// модуля STATE:  W_S(StateTemperature,0,"STATE","Tнаруж")
// Пример для нескольких датчиков:
// #define WAIT_SCREEN_SENSORS W_S(StateTemperature,0,"STATE","Твнутр") ,W_S(StateTemperature,1,"STATE","Tнаруж") ,W_S(StateLuminosity,0,"LIGHT","свет") ,W_S(StateHumidity,0,"HUMIDITY","влажность")
// типы показаний: StateTemperature - температура, StateLuminosity - освещенность, StateHumidity - влажность, StateSoilMoisture - влажность почвы, StatePH - значение pH

// определяем вид экрана ожидания тут
#define WAIT_SCREEN_SENSORS W_S(StateSoilMoisture,0,"SOIL","Почва"), W_S(StateSoilMoisture,1,"SOIL","Почва модуль"), W_S(StateTemperature,0,"STATE","T внутри") ,W_S(StateHumidity,0,"HUMIDITY","Влажность") ,W_S(StateLuminosity,0,"LIGHT","Освещенность")

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// TFT settings (used 7'' screen with SSD1963 controller and 800x480 screen size)
// настройки TFT (используется 7'' экран на контроллере SSD1963 с разрешением 800x480)
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// TFT model
#define TFT_MODEL CTE70 // SSD1963 (16bit) 800x480 Alternative Init
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// TFT RS pin
#define TFT_RS_PIN 38 //25
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// TFT WR pin
#define TFT_WR_PIN 39 //26
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// TFT CS pin
#define TFT_CS_PIN 40 //27
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// TFT RST pin
#define TFT_RST_PIN 41 //28
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// touch settings
// настройки тачскрина
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define TFT_TOUCH_CLK_PIN 6
#define TFT_TOUCH_CS_PIN 5
#define TFT_TOUCH_DIN_PIN 4 //32
#define TFT_TOUCH_DOUT_PIN 3
#define TFT_TOUCH_IRQ_PIN 2
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// раскомментировать, если надо использовать управление подсветкой TFT-экрана через внешний канал
//#define USE_TFT_BACKLIGHT_MANAGE 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// как рулим подсветкой [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define TFT_BACKLIGHT_DRIVE_MODE DRIVE_MCP23S17 // по умолчанию - управление через MCP23S17
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// адрес микросхемы MCP23S17, через которую рулим подсветкой (если управление в режиме DRIVE_MCP23S17)
#define TFT_BACKLIGHT_MCP23S17_ADDRESS 6
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// адрес микросхемы MCP23017, через которую рулим подсветкой (если управление в режиме DRIVE_MCP23017)
// 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.
#define TFT_BACKLIGHT_MCP23017_ADDRESS 0 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// пин или номер канала расширителя портов, на котором висит управление подсветкой (актуально при раскомментированной команде USE_TFT_BACKLIGHT_MANAGE)
#define TFT_BACKLIGHT_DRIVE_PIN 7 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// уровень для выключения подсветки
#define TFT_BACKLIGHT_OFF LOW 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// уровень для включения подсветки
#define TFT_BACKLIGHT_ON HIGH 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// TFT start screen sensors count (maximum 6)
// определение кол-ва датчиков для TFT (максимум - 6)
#define TFT_SENSOR_BOXES_COUNT 6
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// sensor data in format { module_name, sensor_type, sensor_index, sensor_label }
// определение датчиков для TFT, в формате {модуль, тип_показаний, индекс_датчика, подпись_датчика}
// количество - равное TFT_SENSOR_BOXES_COUNT !!!
#define TFT_SENSORS {"STATE",StateTemperature,1,"Снаружи теплицы"}, {"STATE",StateTemperature,0,"Внутри секции 1"}, {"STATE",StateTemperature,2,"Внутри секции 2"}, {"HUMIDITY",StateHumidity,0,"Влажность Si7021"}, {"HUMIDITY",StateHumidity,1,"Влажность DHT22"}, {"LIGHT",StateLuminosity,0,"Освещённость"}
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// decimal separator, comma (charComma) by default. Use charDot for dot.
// разделитель целой и дробной части показаний, по умолчанию - запятая (charComma). Используйте charDot для точки.
#define TFT_SENSOR_DECIMAL_SEPARATOR charComma 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define TFT_INIT_DELAY 0 // сколько миллисекунд (при необходимости) ждать перед отсылкой первых команд на дисплей
#define TFT_EXTRA_RESET // закомментировать, если не нужен дополнительный принудительный пересброс экрана по ноге TFT_RST_PIN
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// цвета для TFT
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define TFT_BACK_COLOR 0xFF,0xFF,0xFF // цвет фона
#define TFT_BUTTON_COLORS VGA_WHITE, VGA_GRAY, VGA_WHITE, VGA_RED, VGA_BLUE // цвета кнопок
#define TFT_FONT_COLOR 0x4B, 0x4C, 0x4B // цвет шрифта по умолчанию
#define TFT_CHANNELS_BUTTON_COLORS 0x3A8D, VGA_SILVER, VGA_GRAY, VGA_RED, 0xEF7D // цвета кнопок для каналов
#define INFO_BOX_BACK_COLOR 97,44,8 // цвет фона для информационного бокса
#define INFO_BOX_BORDER_COLOR VGA_BLACK // цвет рамки информационного бокса
#define INFO_BOX_CAPTION_COLOR 0x30, 0x7B, 0xB5 // цвет заголовка информационного бокса
#define SENSOR_BOX_FONT_COLOR VGA_WHITE // цвет показаний датчика
#define SENSOR_BOX_UNIT_COLOR VGA_WHITE // цвет единиц изменений датчика
#define MODE_ON_COLOR VGA_GREEN   // цвет "вкл", "авто"
#define MODE_OFF_COLOR VGA_MAROON // цвет "выкл", "ручной"
#define CHANNELS_BUTTONS_TEXT_COLOR VGA_WHITE // цвет текста кнопок каналов
#define CHANNELS_BUTTONS_BG_COLOR 0xEF7D    // цвет фона кнопок каналов
#define CHANNEL_BUTTONS_TEXT_COLOR 0x3A8D   // цвет текста кнопки одного канала
#define TIME_PART_FONT_COLOR VGA_TEAL // цвет текста кнопки установки компонента времени
#define TIME_PART_SELECTED_FONT_COLOR VGA_WHITE // цвет текста активной кнопки компонента времени
#define TIME_PART_BG_COLOR 0xEF7D // цвет фона кнопки компонента времени
#define TIME_PART_SELECTED_BG_COLOR VGA_GREEN // цвет фона выбранной кнопки компонента времени
#define STATUS_ON_COLOR VGA_LIME // цвет статусов на экране ожидания
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// labels settings and so on
// настройки подписей и пр.
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#define TFT_WINDOW_STATUS_CAPTION "ФРАМУГИ"
#define TFT_WATER_STATUS_CAPTION "ПОЛИВ"
#define TFT_LIGHT_STATUS_CAPTION "ДОСВЕТКА"
#define TFT_STATUS_CAPTION "Статус:"
#define TFT_MODE_CAPTION "Режим:"
#define TFT_WINDOWS_OPEN_CAPTION "открыты"
#define TFT_WINDOWS_CLOSED_CAPTION "закрыты"
#define TFT_WATER_ON_CAPTION "вкл"
#define TFT_WATER_OFF_CAPTION "выкл"
#define TFT_LIGHT_ON_CAPTION "вкл"
#define TFT_LIGHT_OFF_CAPTION "выкл"
#define TFT_AUTO_MODE_CAPTION "авто"
#define TFT_MANUAL_MODE_CAPTION "ручной"
#define AUTO_MODE_LABEL "РЕЖИМ: АВТО"
#define MANUAL_MODE_LABEL "РЕЖИМ: РУЧНОЙ"
#define OPEN_ALL_LABEL "ОТКРЫТЬ ВСЕ"
#define CLOSE_ALL_LABEL "ЗАКРЫТЬ ВСЕ"
#define TURN_ON_ALL_WATER_LABEL "ВКЛ ПОЛИВ"
#define TURN_OFF_ALL_WATER_LABEL "ВЫКЛ ПОЛИВ"
#define TURN_ON_ALL_LIGHT_LABEL "СВЕТ ВКЛ"
#define TURN_OFF_ALL_LIGHT_LABEL "СВЕТ ВЫКЛ"
#define TFT_TOPEN_CAPTION "Температура открытия:"
#define TFT_TCLOSE_CAPTION "Температура закрытия:"
#define TFT_INTERVAL_CAPTION "Время открытия, с:"
#define TFT_CURRENTTIME_CAPTION "Дата/время (выделите компонент для изменения):"
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// backlight OFF delay, if no actions with screen found, ms
// время выключения при бездействии, миллисекунд
#define TFT_OFF_DELAY 15000 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// update sensors data interval, ms
// через сколько миллисекунд перечитывать показания с датчиков
#define TFT_SENSORS_UPDATE_INTERVAL 5000 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------------------------------------
// Настройки W5100 (актуально при раскомментированной команде USE_W5100_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define W5100_REBOOT_PIN 61 // номер пина, на котором будет управление питанием W5100 - пока реализовано только включение (актуально при раскомментированной команде USE_W5100_REBOOT_PIN)
#define W5100_POWER_OFF HIGH // уровень для выключения питания
#define W5100_POWER_ON LOW // уровень для включения питания

//--------------------------------------------------------------------------------------------------------------------------------
// Настройки Nextion (актуально при раскомментированной команде USE_NEXTION_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_NEXTION_HARDWARE_UART // закомментировать, если надо использовать программный UART (дополнительные 2 пина) вместо аппаратного (аппаратный остаётся свободен)
// ВНИМАНИЕ: ПОДДЕРЖКА ПРОГРАММНОГО UART - НАХОДИТСЯ В ЭКСПЕРИМЕНТАЛЬНОЙ СТАДИИ!!!
#define NEXTION_SOFTWARE_UART_RX_PIN A14 // пин RX для SoftwareSerial при общении с Nextion через программный UART
#define NEXTION_SOFTWARE_UART_TX_PIN A15 // пин ТX для SoftwareSerial при общении с Nextion через программный UART

#define NEXTION_SERIAL Serial3 // какой Serial используем для Nextion (ВНИМАНИЕ! Если используется RS-485 - Nextion по умолчанию сидит на этом же Serial, конфликт!)
#define NEXTION_SLEEP_DELAY 60 // через сколько секунд переходить в сон, если ничего не сделано на экране
#define NEXTION_WAIT_TIMER 10000 // интервал таймера переключения на экран ожидания, мс
#define NEXTION_ROTATION_INTERVAL 7000 // через сколько мс менять на экране ожидания показания с датчиков

// настройки экрана ожидания
// на экране ожидания можно выводить N показаний любых поддерживаемых системой датчиков.
// для добавления показаний с датчика используйте конструкцию NW_S.
// показания добавляются в NEXTION_WAIT_SCREEN_SENSORS, через запятую, например:
// добавляем на экран ожидания показания температурного датчика с индексом 0
// модуля STATE:  NW_S(StateTemperature,0,"STATE","Т внутри")
// Пример для нескольких датчиков:
// #define NEXTION_WAIT_SCREEN_SENSORS NW_S(StateTemperature,0,"STATE", "Т внутри") ,NW_S(StateTemperature,1,"STATE", "Т снаружи") ,NW_S(StateLuminosity,0,"LIGHT", "Свет") ,NW_S(StateHumidity,0,"HUMIDITY", "Влажность")

// определяем вид экрана ожидания тут
#define NEXTION_WAIT_SCREEN_SENSORS NW_S(StateTemperature,0,"STATE", "Т внутри") ,NW_S(StateHumidity,1,"HUMIDITY", "Влажность") ,NW_S(StateLuminosity,0,"LIGHT", "Свет")

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля учёта воды (актуально при раскомментированной команде USE_WATERFLOW_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// модуль занимает пины 2 и 3 меги, т.к. работает по прерываниям. Для Due юзаются пины 11 и 12.
// поддерживаемые типы датчиков - китайские water flow meter с датчиком Холла.
// подключение простое: питание, земля, линию данных - на пин FIRST_WATERFLOW_PIN для первого датчика, на пин SECOND_WATERFLOW_PIN - для второго датчика.

#define FIRST_WATERFLOW_PIN 11 // пин для первого расходомера
#define SECOND_WATERFLOW_PIN 12 // пин для второго расходомера 

#define WATERFLOW_SENSORS_COUNT 2 // доступные значения: 0, 1, 2. Если 0 - никакие показания сниматься не будут, следовательно, пины FIRST_WATERFLOW_PIN и SECOND_WATERFLOW_PIN останутся свободны
#define WATERFLOW_SAVE_DELTA 10 // через сколько накопленных литров сохранять в EEPROM значение с датчика

// сколько пульсаций в секунду выдаёт датчик при протекании литра за минуту - 
// калибровочное значение, если не совпадает с реальным расходом - подбирать!
#define WATERFLOW_CALIBRATION_FACTOR 45 // фактор калибровки по умолчанию, можно потом менять через конфигуратор

#define WATERFLOW_CHECK_FREQUENCY 2000 // через сколько мс обновлять показания с датчиков расхода


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления по SMS (модем  SIM800) (актуально при раскомментированной команде USE_SMS_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define GSM_SERIAL Serial2 // какой хардварный Serial будем использовать при работе с модемом?
#define GSM_AVAILABLE_CHECK_TIME 60000 // через сколько миллисекунд проверять доступность модема посылкой команды AT
#define GSM_WAIT_BOOT_TIME 2000 // сколько мс ждать загрузки модема
#define GSM_CHECK_REGISTRATION_INTERVAL 4567 // через сколько мс проверять регистрацию в сети (повторные вызовы с указанным промежутком до тех пор, пока модем не зарегистрируется)
#define GSM_REBOOT_TIME 2000 // сколько миллисекунд держать питание выключенным при перезагрузке модема, если он завис
#define GSM_WAIT_AFTER_REBOOT_TIME 5000 // сколько мс ждать после перезагрузки модема прежде, чем начать обрабатывать команды
#define GSM_MAX_ANSWER_TIME 60000 // через сколько мс, если не получен ответ на команду от модема, считать его зависшим
#define GSM_REBOOT_PIN 65 // номер пина, на котором будет управление питанием GSM-модема (актуально при раскомментированной команде USE_GSM_REBOOT_PIN)
#define GSM_POWER_OFF HIGH // уровень для выключения питания
#define GSM_POWER_ON LOW // уровень для включения питания

#define GSM_PULL_GPRS_BY_PING // закомментировать, если не надо периодически пинговать выбранный хост (нужно, чтобы поддерживать GPRS-соединение при очень редких запросах в сеть)
#define GSM_PING_INTERVAL 45000 // интервал в миллисекундах для пинга
#define GSM_PING_HOST F("ya.ru") // хост, который пингуем

// раскомментировать, если нужно управление подачей питания на SIM800 (вход POWERKEY)
// при этом на нужный выход МК подаётся импульс нужного уровня нужной длительности
// для включения модема в работу
#define USE_SIM800_POWERKEY 
#define SIM800_POWERKEY_PIN 67 // номер пина, на котором будет импульс для включения модема в работу
#define SIM800_POWERKEY_PULSE_DURATION 300 // сколько миллисекунд держать импульс
#define SIM800_POWERKEY_OFF_LEVEL HIGH // начальный уровень на выходе POWERKEY
#define SIM800_POWERKEY_ON_LEVEL LOW // уровень, который держится нужное кол-во времени
#define SIM800_WAIT_POWERKEY_AFTER_POWER_ON 500 // сколько миллисекунд ждать после подачи питания до подачи импульса POWERKEY

#define SEND_WINDOW_STATE_IN_STATUS_SMS // закомментировать, если не надо посылать статус окон в СМС статистики
#define SEND_WATER_STATE_IN_STATUS_SMS // закомментировать, если не надо посылать статус полива в СМС статистики

//#define SEND_WORK_STARTED_SMS // закомментировать, если не надо посылать СМС о том, что контроллер начал работу
#define WORK_STARTED_SMS_TEXT F("Контроллер начал работу.") // текст СМС, который будет посылаться при старте контроллера в работу

// настройки датчиков для СМС статистики по умолчанию (если нет SD-карты или там ничего не сохранено)
// индексы модулей:
// 1 - модуль температур
// 2 - модуль влажности
// 3 - модуль освещённости
// 4 - модуль влажности почвы

#define STATUS_SMS_DEFAULT_MODULE1 1 // модуль для первого датчика
#define STATUS_SMS_DEFAULT_SENSOR1 0 // индекс датчика в первом модуле
#define STATUS_SMS_DEFAULT_LABEL1 F("Твнутр") // подпись по умолчанию для первого датчика

#define STATUS_SMS_DEFAULT_MODULE2 1 // модуль для второго датчика
#define STATUS_SMS_DEFAULT_SENSOR2 1 // индекс датчика во втором модуле
#define STATUS_SMS_DEFAULT_LABEL2 F("Тнаруж") // подпись по умолчанию для второго датчика


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля WI-FI (актуально при раскомментированной команде USE_WIFI_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// ПРОШИВКА ДЛЯ ESP НАХОДИТСЯ В ПАПКЕ ESP_AT - РАБОТОСПОСОБНОСТЬ ПРОВЕРЕНА ТОЛЬКО В СВЯЗКЕ С ЭТОЙ ПРОШИВКОЙ!!!
// ИНСТРУКЦИИ ПО ПРОШИВКЕ НАХОДЯТСЯ В ТОЙ ЖЕ ПАПКЕ, В ФАЙЛЕ README.TXT!!!
// НАСТОЯТЕЛЬНО РЕКОМЕНДУЕТСЯ ИСПОЛЬЗОВАТЬ ПИН УПРАВЛЕНИЕ ПИТАНИЕМ ДЛЯ ПОЛНОГО ПЕРЕСБРОСА ESP!!!
//--------------------------------------------------------------------------------------------------------------------------------
#define WIFI_SERIAL Serial1 // какой хардварный сериал использовать для WI-FI?
#define STATION_ID F("TEPLICA") // ID точки доступа, которую создаёт модуль WI-FI
#define STATION_PASSWORD F("12345678") // пароль к точке доступа, которую создаёт вай-фай (МИНИМУМ 8 СИМВОЛОВ, ИНАЧЕН НЕ БУДЕТ РАБОТАТЬ!)
#define ROUTER_ID F("")  // SSID домашнего роутера, к которому коннектится модуль WI-FI
#define ROUTER_PASSWORD F("") // пароль к домашнему роутеру, к которому коннектится модуль WI-FI

#define WIFI_AVAILABLE_CHECK_TIME 60000 // через сколько миллисекунд проверять доступность ESP посылкой команды AT
#define WIFI_REBOOT_TIME 2000 // сколько миллисекунд держать питание выключенным при перезагрузке ESP, если он завис
#define WIFI_WAIT_BOOT_TIME 2000 // сколько мс ждать загрузки модема
#define WIFI_WAIT_AFTER_REBOOT_TIME 5000 // сколько мс ждать после перезагрузки ESP прежде, чем начать обрабатывать команды
#define WIFI_MAX_ANSWER_TIME 60000 // через сколько мс, если не получен ответ на команду от модема, считать его зависшим
#define WIFI_IPD_READING_TIMEOUT 1000 // таймаут на чтение входящих данных от ESP, миллисекунд (+IPD)
#define WIFI_REBOOT_PIN 59 // номер пина, на котором будет управление питанием GSM-модема (актуально при раскомментированной команде USE_WIFI_REBOOT_PIN)
#define WIFI_POWER_OFF HIGH // уровень для выключения питания
#define WIFI_POWER_ON LOW // уровень для включения питания

//--------------------------------------------------------------------------------------------------------------------------------
// настройки тревог (актуально при раскомментированной команде USE_ALARM_DISPATCHER)
//--------------------------------------------------------------------------------------------------------------------------------
#define ALARM_SMS_TEXT F("Тревога! Сработало правило: ") // текст СМС, который отправится при срабатывании тревожного правила, к СМС будет добавлено имя правила
//#define CLEAR_ALARM_STATUS // раскомментировать, если надо очищать сработавшие тревоги через указанный ниже промежуток времени. 
//Если тревоги не очищаются - SMS посылается однократно, до перезагрузки контроллера
#define ALARM_CLEAR_INTERVAL 10 // интервал между очистками сработавших тревог, в минутах


#endif
