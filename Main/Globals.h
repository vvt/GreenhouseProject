#ifndef _GLOBALS_H
#define _GLOBALS_H

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ПОЛЬЗОВАТЕЛЬСКИЕ НАСТРОЙКИ
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------------------------------------------------
// директивы условной компиляции:
/*
    в общем случае для предварительной настройки прошивки достаточно закомментировать ту или иную директиву USE_*.
    конкретные настройки пинов и пр. - находятся после директив условной компиляции, и подхватываются только тогда,
    когда соответствующая директива USE_* определена.
 */
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_DS3231_REALTIME_CLOCK // закомментировать, если не хотим использовать модуль реального времени (DS3231)
#define USE_PIN_MODULE // закомментировать, если не нужен модуль управления пинами
#define USE_TEMP_SENSORS // закомментировать, если не нужно управление окнами по температуре
#define USE_WINDOWS_SHIFT_REGISTER // использовать ли сдвиговый регистр 74HC595 для управления окнами, вместо контроля пинов напрямую (см. настройки фрамуг ниже)
#define USE_STAT_MODULE // закомментировать, если не нужна поддержка модуля статистики (FREERAM, UPTIME, DATETIME)
#define USE_SMS_MODULE // закомментировать, если не нужна поддержка управления по SMS
#define USE_WATERING_MODULE // закомментировать, если не нужен модуль управления поливом (в принципе, тот же функционал можно реализовать через правила)
#define USE_LUMINOSITY_MODULE // закомментировать, если не нужен модуль контроля освещенности (BH1750)
#define USE_HUMIDITY_MODULE // закомментировать, если не нужен модуль работы с датчиками влажности DHT и Si7021
#define USE_SOIL_MOISTURE_MODULE // закомментировать, если не нужен модуль датчиков влажности почвы
#define USE_PH_MODULE // закомментировать, если не нужен модуль снятия показаний с датчиков pH и контроля за дозированием реагентов в систему
#define USE_LOG_MODULE // закомментировать, если не нужен модуль логгирования информации. Внимание: модуль работает только с модулем реального времени (USE_DS3231_REALTIME_CLOCK должна быть определена!)
#define USE_DELTA_MODULE // закомментировать, если не нужно собирать показания дельт с датчиков (разница показаний между двумя датчиками)
#define USE_WATERFLOW_MODULE // закомментировать, если не нужны датчик(и) расхода воды (пин(ы) 2 (и 3) меги), настройки - см. ниже
#define USE_COMPOSITE_COMMANDS_MODULE // закомментировать, если не нужен модуль составных команд (позволяет выполнить скопом несколько разных действий, используется правилами)
#define USE_RESERVATION_MODULE // закомментировать, если не нужем модуль резервирования датчиков (когда при отсутствии показаний с одного датчика показания берутся со связанных с ним).
// модуль резервирования нужен для работы правил, если необходимо обеспечить работу правила даже тогда, когда один из датчиков вышел из строя
#define USE_TIMER_MODULE // закомментировать, если не нужна поддержка модуля таймеров (4 таймера)
#define USE_IOT_MODULE // закомментировать, если не нужна отсылка данных на IoT-хранилища (ThingSpeak). Настройки IoT смотрите ниже
#define USE_ALARM_DISPATCHER // закомментировать, если не нужны тревоги (получение СМС при срабатывании правила)
#define USE_WIFI_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании ESP (если ESP долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
#define USE_GSM_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании модема (если GSM-модем долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
#define USE_NRF_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании nRF (если nRF долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
#define USE_W5100_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании W5100 (если W5100 долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
#define USE_EXTERNAL_WATCHDOG // закомментировать, если не нужен внешний контроль зависания меги (мега на определённой ноге дёргает уровни, если уровни не меняются - внешний ватчдог передёргивает питание)
#define USE_WIFI_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать ESP как один из шлюзов для отсыла данных в IoT
//#define USE_GSM_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать GSM-модем как один из шлюзов для отсыла данных в IoT
#define USE_UNIVERSAL_SENSORS // закомментировать, если не нужно использовать универсальные модули с датчиками на борту
#define USE_UNI_NEXTION_MODULE // закомментировать, если не нужен выносной модуль с дисплеем Nextion на шине 1-Wire
#define USE_UNI_EXECUTION_MODULE // закомментировать, если не нужна поддержка универсальных исполнительных модулей
#define USE_UNI_REGISTRATION_LINE // закомментировать, если не нужна проводная линия 1-Wire для регистрации универсальных модулей
#define USE_RS485_GATE // закомментировать, если не нужна поддержка опроса универсальных модулей по протоколу RS-485
#define USE_NRF_GATE // закомментировать, если не нужно работать с универсальными модулями по радиоканалу
#define USE_PUMP_RELAY // закомментировать, если не нужен отдельный канал управления насосом при поливе (настройки - ниже)
//#define USE_SECOND_PUMP // использовать ли второй насос для полива (настройки - ниже). Директива USE_PUMP_RELAY при использовании второго насоса также должна быть определена!
#define USE_HTTP_MODULE // закомментировать, если не нужна проверка на входящие команды (путём запроса внешнего адреса по HTTP)
//--------------------------------------------------------------------------------------------------------------------------------
// расширители портов
//--------------------------------------------------------------------------------------------------------------------------------

// использовать или нет расширители портов MCP23S17, при этом модули, которые поддерживают работу через эти расширители, могут работать через них. 
// Настройки расширителя на SPI смотрите ниже.
//#define USE_MCP23S17_EXTENDER // раскомментировать, если хотите использовать MCP23S17 (работу через них поддерживает модуль полива и модуль досветки)

// использовать или нет расширители портов MCP23017, при этом модули, которые поддерживают работу через эти расширители, могут работать через них. 
// Настройки расширителя на I2C смотрите ниже.
//#define USE_MCP23017_EXTENDER // раскомментировать, если хотите использовать MCP23017 (работу через них поддерживает модуль полива и модуль досветки)

//--------------------------------------------------------------------------------------------------------------------------------
// шлюзы (ИСПОЛЬЗОВАТЬ ВМЕСТЕ НЕ ДОПУСКАЕТСЯ, прошивка не скомпилируется!)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE // закомментировать, если не нужна поддержка управления через Wi-Fi (ESP8266) (не работает совместно с USE_W5100_MODULE!)
//#define USE_W5100_MODULE // закомментировать, если не нужна работа по Ethernet через W5100 (не работает совместно с USE_WIFI_MODULE!)

//--------------------------------------------------------------------------------------------------------------------------------
// экраны (ИСПОЛЬЗОВАТЬ ВМЕСТЕ НЕ ДОПУСКАЕТСЯ, прошивка не скомпилируется!)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_LCD_MODULE // закомментировать, если не нужен дисплей 128х64 на базе контроллера ST7920
//#define USE_NEXTION_MODULE // закомментировать, если не нужна поддержка Nextion

//--------------------------------------------------------------------------------------------------------------------------------
// информационные диоды
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_READY_DIODE // закомментировать, если не нужен диод, горящий при работе контроллера (пин номер DIODE_READY_PIN)
#define BLINK_READY_DIODE // закомментировать, если не нужно периодически мигать диодом работы
#define USE_WINDOWS_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления фрамугами (пин DIODE_WINDOWS_MANUAL_MODE_PIN)
#define USE_WATERING_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления поливом (пин DIODE_WATERING_MANUAL_MODE_PIN)
#define USE_LIGHT_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления досветкой (пин DIODE_LIGHT_MANUAL_MODE_PIN)


//--------------------------------------------------------------------------------------------------------------------------------
/*
 ниже идут конкретные настройки того или иного функционала.
 */

//--------------------------------------------------------------------------------------------------------------------------------
// определения вида управления пинами (настройки управления по тому или иному принципу специфичны для каждого модуля, их смотрите ниже)
//--------------------------------------------------------------------------------------------------------------------------------
#define DRIVE_DIRECT 1    // прямое управление пинами
#define DRIVE_MCP23S17 2  // через расширитель портов MCP23S17
#define DRIVE_MCP23017 3 // через расширитель портов MCP20S17

//--------------------------------------------------------------------------------------------------------------------------------
// настройки расширителей портов MCP23S17 (актуально при раскомментированной команде USE_MCP23S17_EXTENDER)
//--------------------------------------------------------------------------------------------------------------------------------
#define MCP23S17_CS_PIN 10 // номер пина chip select для микросхем MCP23S17
#define COUNT_OF_MCP23S17_EXTENDERS 2 // сколько расширителей портов MCP23S17 используется (0 - нисколько)
#define MCP23S17_ADDRESSES 0, 1 // адреса расширителей MCP23S17, через запятую, кол-вом COUNT_OF_MCP23S17_EXTENDERS

//--------------------------------------------------------------------------------------------------------------------------------
// настройки расширителей портов MCP23017 (актуально при раскомментированной команде USE_MCP23017_EXTENDER)
//--------------------------------------------------------------------------------------------------------------------------------
#define COUNT_OF_MCP23017_EXTENDERS 2 // сколько расширителей портов MCP23017 используется (0 - нисколько)
// адреса расширителей MCP23017, через запятую, кол-вом COUNT_OF_MCP23017_EXTENDERS
// 0 - первый адрес 0x20, 1 - второй адрес 0x21 и т.п.
#define MCP23017_ADDRESSES 4,5 

//--------------------------------------------------------------------------------------------------------------------------------
// НАСТРОЙКИ ВНЕШНЕГО ВАТЧДОГА (актуально при раскомментированной команде USE_EXTERNAL_WATCHDOG)
//--------------------------------------------------------------------------------------------------------------------------------
#define WATCHDOG_REBOOT_PIN A5 // номер пина, на котором будут меняться уровни
#define WATCHDOG_WORK_INTERVAL 5000 // через сколько миллисекунд на ноге будет высокий уровень
#define WATCHDOG_PULSE_DURATION 20 // сколько миллисекунд держать высокий уровень на ноге

//--------------------------------------------------------------------------------------------------------------------------------
// НАСТРОЙКИ УНИВЕРСАЛЬНЫХ МОДУЛЕЙ С ДАТЧИКАМИ, А ТАКЖЕ ИСПОЛНИТЕЛЬНЫХ УНИВЕРСАЛЬНЫХ МОДУЛЕЙ (актуально при раскомментированной команде USE_UNIVERSAL_SENSORS)
//--------------------------------------------------------------------------------------------------------------------------------
#define UNI_REGISTRATION_PIN 28 // номер пина, на котором будут регистрироваться модули в системе (актуально при раскомментированной команде USE_UNI_REGISTRATION_LINE)
#define UNI_MODULE_UPDATE_INTERVAL 2000 // через сколько мс обновлять показания с универсального модуля
#define UNI_WIRED_MODULES_COUNT 1 // сколько проводных линий для универсальных модулей используется (0 - нисколько)
// ДЛЯ ПЛАТЫ ВЫВОДЫ ПО УМОЛЧАНИЮ, ПОДТЯНУТЫЕ РЕЗИСТОРАМИ - A11, A12, A13
#define UNI_WIRED_MODULES A12//, A13 // номера пинов (через запятую), на которых висят универсальные модули, кол-вом  UNI_WIRED_MODULES_COUNT

// показания с каких датчиков передавать выносному модулю с дисплеем Nextion? максимум 5 датчиков (актуально при раскомментированной команде USE_UNI_NEXTION_MODULE)
#define UNI_NEXTION_WAIT_SCREEN_SENSORS {StateTemperature,0,"STATE"}, {StateHumidity,1,"HUMIDITY"}, {StateLuminosity,0,"LIGHT"}

//--------------------------------------------------------------------------------------------------------------------------------
// настройки RS-485 (актуально при раскомментированной команде USE_RS485_GATE)
//--------------------------------------------------------------------------------------------------------------------------------
#define RS_485_SERIAL Serial3 // ВНИМАНИЕ! СЛЕДИТЕ ЗА ОТСУТСТВИЕМ КОНФЛИКТОВ С SERIAL. ЭТОТ ЖЕ SERIAL ИСПОЛЬЗУЕТСЯ Nextion, т.е. либо Nextion по Serial, либо - RS-485!!!
#define RS_485_UCSR UCSR3A // регистр, связанный с номером UART RS_485_SERIAL
#define RS_485_TXC TXC3 // бит ТХ, связанный с номером UART RS_485_SERIAL
#define RS_485_DE_PIN 26 // номер пина, на котором будет происходить переключение приёма/передачи по RS-485
#define RS485_SPEED 57600 // скорость работы по RS-485
#define RS495_STATE_PUSH_FREQUENCY 1000 // через сколько миллисекунд писать в шину RS-485 слепок состояния контроллера
#define RS485_ONE_SENSOR_UPDATE_INTERVAL 1234 // через сколько миллисекунд запрашивать с шины RS-485 показания одного датчика (полный цикл опроса будет равен интервалу*кол-во датчиков в системе)
#define RS485_BYTES_TIMEOUT 10 // кол-во байт, после неуспешной попытки вычитки которых принимать решение о таймауте (если данные по RS-485 не ходят - увеличьте это значение).

//--------------------------------------------------------------------------------------------------------------------------------
// настройки nRF (актуально при раскомментированной команде USE_NRF_GATE)
//--------------------------------------------------------------------------------------------------------------------------------
#define UNI_DEFAULT_RF_CHANNEL 19 // номер канала для nRF по умолчанию
#define NRF_CE_PIN A8 // номер пина CE для модуля nRF
#define NRF_CSN_PIN A9 // номер пина CSN для модуля nRF
#define NRF_CONTROLLER_STATE_CHECK_FREQUENCY 789 // через сколько миллисекунд проверять смену состояния контроллера (для отсылки в эфир при изменениях)
// номер пина для пересброса питания nRF (в текущей версии управление питанием не реализовано - на этот пин для платы просто подаётся нужный уровень)
#define NRF_REBOOT_PIN 30 // (актуально при раскомментированной команде USE_NRF_REBOOT_PIN) 
#define NRF_POWER_ON HIGH
#define NRF_POWER_OFF LOW
//#define NRF_AUTOACK_INVERTED // раскомментировать эту строчку здесь и в прошивках универсальных модулей, если у вас они не коннектятся. 
// Иногда auto aсk в китайских модулях имеет инвертированное значение.
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля периодических таймеров, 4 штуки (актуально при раскомментированной команде USE_TIMER_MODULE) 
//--------------------------------------------------------------------------------------------------------------------------------
#define TIMER_ON HIGH // уровень, который надо выставлять на пине, когда таймер включён
#define TIMER_OFF LOW // уровень, который надо выставлять на пине, когда таймер выключён

//--------------------------------------------------------------------------------------------------------------------------------
// настройки EEPROM для хранения данных
//--------------------------------------------------------------------------------------------------------------------------------
// определения типов памяти, поддерживаемых прошивкой
//--------------------------------------------------------------------------------------------------------------------------------
#define EEPROM_BUILTIN 1 // встроенный EEPROM
#define EEPROM_AT24C32 2 // I2C-память AT24C32 
#define EEPROM_AT24C64 3 // I2C-память AT24C64 
#define EEPROM_AT24C128 4 // I2C-память AT24C128 
#define EEPROM_AT24C256 5 // I2C-память AT24C256 
#define EEPROM_AT24C512 6 // I2C-память AT24C512 
//--------------------------------------------------------------------------------------------------------------------------------
// тут определяем, какую память мы используем
//--------------------------------------------------------------------------------------------------------------------------------
#define EEPROM_USED_MEMORY EEPROM_BUILTIN // по умолчанию используем встроенную в мегу память
//--------------------------------------------------------------------------------------------------------------------------------
#define SETT_HEADER1 0x1F // байты, сигнализирующие о наличии сохранённых настроек, первый
#define SETT_HEADER2 0xBF // и второй
//--------------------------------------------------------------------------------------------------------------------------------
// ВНИМАНИЕ! МНОГИЕ НАСТРОЙКИ, ТАКИЕ, КАК настройки каналов полива, Wi-Fi, IoT и т.п. - пишутся с нулевого адреса EEPROM.
// Поэтому будьте внимательны, чтобы до адреса ID контроллера хватило места для записи данных настроек!!!
// Если интересуют подробности, то в файлах Settings.cpp и Settings.h всё более чем прозрачно, однако следует учесть тот момент,
// что длина хранимых данных вычисляется эмпирически, из-за их (данных) переменной длины. Поэтому всегда должен быть запас.
//--------------------------------------------------------------------------------------------------------------------------------
// адреса хранения данных в EEPROM (МИНИМАЛЬНЫЙ ОБЪЁМ EEPROM - 4 Кб !!!)
//--------------------------------------------------------------------------------------------------------------------------------
#define CONTROLLER_ID_EEPROM_ADDR 429 // по какому адресу располагается ID контроллера
#define UNI_SENSOR_INDICIES_EEPROM_ADDR 430 // с какого адреса идут выданные индексы для универсальных сенсоров
#define WATERING_STATUS_EEPROM_ADDR 450 // с какого адреса у нас идут статусы каналов полива (для сохранения флага - сколько поливали сегодня), 100 байт хватит на 16 каналов 
#define WATERFLOW_EEPROM_ADDR 550 // с какого адреса у нас будут записываться показания датчиков расхода воды (пишутся только накопительные показания, по 4 байта на счётчик, 2 счётчика = 8 байт, 2 байта - факторы калибровки, 2 оставшихся - про запас)
#define DELTA_SETTINGS_EEPROM_ADDR 562 // с какого адреса в EEPROM начинаются настройки дельт, до начала адреса правил вместится 20 дельт
#define EEPROM_RULES_START_ADDR 1075 // со второго килобайта в EEPROM идут правила
#define PH_SETTINGS_EEPROM_ADDR 2850 // с какого адреса идут настройки PH-модуля: заголовок (2 байта), номер пина, с которого читать показания (1 байт), калибровка (в сотых долях, 2 байта), остальное - пока резерв
#define TIMERS_EEPROM_ADDR 2900 // у нас 4 таймера, на каждый - 10 байт + заголовок (2 байта), итого - 42 байта 
#define RESERVATION_ADDR 2950 // адрес, с которого пишутся настройки резервирования (173 байта до составных команд; 10 списков по 12 байт + 3 байта = 123 байта, запас ещё есть)
#define COMPOSITE_COMMANDS_START_ADDR 3123 // с четвёртого килобайта в EEPROM идут составные команды
#define GUID_ADDRESS 4000 // адрес, по которому хранится уникальный GUID контроллера (32 символа без пробелов + 2 байта - заголовок присутствия)
#define HTTP_API_KEY_ADDRESS 4035 // адрес, ко которому хранится ключ доступа к HTTP API (32 символа без пробелов + 2 байта - заголовок присутствия + 1 байт - флаг активности, вкл/выкл)
#define TIMEZONE_ADDRESS 4071 // адрес хранения часового пояса контроллера, 4 байта (2 байта заголовок присутствия, 2 байта - таймзона). Хранится в минутах
#define HTTP_SEND_SENSORS_DATA_ADDRESS 4075 // адрес хранения флага - отсылать ли слепок показаний датчиков контроллера при проверке задач по HTTP
#define HTTP_SEND_STATUS_ADDRESS 4076 // адрес хранения флага - отсылать ли слепок состояния контроллера при проверке задач по HTTP
//--------------------------------------------------------------------------------------------------------------------------------
// настройки Serial
//--------------------------------------------------------------------------------------------------------------------------------
#define SERIAL_BAUD_RATE 57600 // скорость работы с портом, бод (конфигуратор работает с портом именно на скорости 57600)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки информационных диодов и других пинов 
//--------------------------------------------------------------------------------------------------------------------------------
#define DIODE_READY_PIN 6 // пин, на котором висит диод индикации работы (актуально при раскомментированной команде USE_READY_DIODE)
#define DIODE_WINDOWS_MANUAL_MODE_PIN 7 // пин, на котором будет диод, мигающий, когда мы в ручном режиме управления окнами (актуально при раскомментированной команде USE_WINDOWS_MANUAL_MODE_DIODE)
#define DIODE_WATERING_MANUAL_MODE_PIN 8 // пин, на котором висит диод индикации ручного режима управления поливом (актуально при раскомментированной команде USE_WATERING_MANUAL_MODE_DIODE)
#define DIODE_LIGHT_MANUAL_MODE_PIN 9 // пин, на котором висит диод индикации ручного режима управления досветкой (актуально при раскомментированной команде USE_LIGHT_MANUAL_MODE_DIODE)
#define WORK_MODE_BLINK_INTERVAL 500 // с какой частотой мигать на пинах индикации ручного режима работы, мс
#define READY_DIODE_BLINK_INTERVAL 5000 // с какой частотой мигать диодом работы, мс
#define SDCARD_CS_PIN 53 // номер пина Chip Select для SD-модуля 
#define VIRTUAL_PIN_START_NUMBER 80 // номер пина, с которого все пины будут считаться виртуальными, т.е. запись в них производиться не будет, однако в карте пинов (16 байт) этот статус будет отражён.

//--------------------------------------------------------------------------------------------------------------------------------
// настройки железных модулей реле 
//--------------------------------------------------------------------------------------------------------------------------------
#define RELAY_ON LOW // уровень для включения реле
#define RELAY_OFF HIGH // уровень для выключения реле
#define SHORT_CIRQUIT_STATE HIGH // статус пинов, на которых висит реле, чтобы закоротить мотор и не дать ему крутиться

//--------------------------------------------------------------------------------------------------------------------------------
// настройки максимумов
//--------------------------------------------------------------------------------------------------------------------------------
#define MAX_ALERT_RULES 30 // максимальное кол-во поддерживаемых правил
#define MAX_DELTAS 20 // максимальное кол-во дельт. Внимание: на 20 дельт нужно примерно 500 байт в EEPROM, поэтому если нужно больше 20 - смените адрес записи правил в EEPROM на бОльший!

//--------------------------------------------------------------------------------------------------------------------------------
// настройки интервалов обновлений модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define ALERT_UPDATE_INTERVAL 500 // интервал обновления состояния модуля ALERT, мс. Нужен, чтобы часто не разрешать зависимости - это ресурсоёмкая операция.
#define LOGGING_INTERVAL 300000 // интервал логгирования, мс (300000 - каждые 5 минут и т.п.)
#define LUMINOSITY_UPDATE_INTERVAL 3000 // через сколько мс обновлять показания с датчиков освещенности 
#define HUMIDITY_UPDATE_INTERVAL 5000 // через сколько мс обновлять показания с датчиков влажности
#define TEMP_UPDATE_INTERVAL 4990 // через сколько мс обновлять показания с датчиков температуры
#define DELTA_UPDATE_INTERVAL 5010 // через сколько миллисекунд обновлять показания дельт?

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля освещенности (BH1750) (актуально при раскомментированной команде USE_LUMINOSITY_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// режимы управления пинами - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define LIGHT_DRIVE_MODE DRIVE_DIRECT // прямое управление пинами, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим каналами досветки (если управление в режиме DRIVE_MCP23S17)
#define LIGHT_MCP23S17_ADDRESS 1

// адрес микросхемы MCP23017, через которую рулим каналами досветки (если управление в режиме DRIVE_MCP23017)
#define LIGHT_MCP23017_ADDRESS 0 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// уровни для реле каналов досветки
#define LIGHT_RELAY_ON LOW // уровень для включения реле
#define LIGHT_RELAY_OFF HIGH // уровень для выключения реле

#define LIGHT_SENSORS_COUNT 2 // кол-во проводных датчиков освещенности, 0, 1 или 2, 2 - максимум
#define LAMP_RELAYS_COUNT 4 // кол-во реле для управления досветкой, максимум - 8 каналов

// пины, на которых сидят реле управления досветкой (через запятую, кол-во равно LAMP_RELAYS_COUNT!)
// в случае управления через расширители портов (DRIVE_MCP23S17, DRIVE_MCP23017) - номера каналов микросхемы 
#define LAMP_RELAYS_PINS 34,35,36,37 

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля контроля pH (РАБОТАЕТ ЧЕРЕЗ МИКРОСХЕМУ PCF8574T на шине I2C !!!) (актуально при раскомментированной команде USE_PH_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
/*
 Принцип работы модуля контроля pH:
 
   1. Все каналы заведены через микросхему PCF8574T, которую можно подсоединить как прямо к меге, 
      так и вытащить через удлинитель I2C;
      
   2. К одному из каналов подключен датчик понижения уровня жидкости в ёмкости с рабочим раствором, 
      который при срабатывании выдаёт сигнал определённого уровня;
      
   3. При срабатывании датчика уровня начинается пополнение ёмкости с рабочим раствором, для этого на канал, 
      к которому подключен клапан подачи воды - подаётся определённый уровень;
      
   4. Как только ёмкость заполнена - начинается контроль pH;
   
   5. При отклонении pH от нужных значений, в зависимости от направления отклонения - 
      на каналы клапанов для повышения/понижения значения pH подаётся нужный уровень;
      
   6. После подачи корректировочного раствора в нужном объёме на канал управление насосом, 
      перемешивающим рабочий раствор, подаётся нужный уровень;
      
   7. После окончания перемешивания система продолжает контролировать pH, периодически при необходимости 
      повторяя вышеописанные действия, чтобы добиться требуемого уровня pH.
   
 */
//--------------------------------------------------------------------------------------------------------------------------------
#define PCF8574_ADDRESS 0x27 // адрес микросхемы для контроля pH на шине I2C (0x20 - 0x27)
#define PH_SENSOR_PIN A14 // номер аналогового пина, с которого читать показания датчика (0 - нет датчика, прикреплённого к меге)
#define PH_SAMPLES_PER_MEASURE 10 // сколько делать замеров на одно измерение pH (1-255)
#define PH_SAMPLES_INTERVAL 20 // сколько миллисекунд между замерами в одном цикле измерения делать (10 - 255)
#define PH_UPDATE_INTERVAL 15678 // через сколько миллисекунд обновлять показания с датчика pH, прикреплённого к меге
#define PH_DEFAULT_CALIBRATION 0 // поправочное число по умолчанию, в сотых долях (т.е. 1 - это 0,01 сотая, 10 - это 0,1 и т.п.)
#define PH_DEFAULT_TARGET 700 // желаемое значение pH раствора на выходе, по умолчанию, целое число (700 = 7.00, 651 = 6.51 и т.п.)

// значение гистерезиса по умолчанию, в сотых долях (50 = 0.5, 100 = 1.0, 123 = 1.23 и т.п.). 
// Если pH раствора находится в рамках гистерезиса - корректировки pH не происходит.
#define PH_DEFAULT_HISTERESIS 50 // гистерезис

#define PH_DEFAULT_MIX_PUMP_TIME 60 // время работы насоса перемешивания по умолчанию, после каждой корректировки pH, секунд
#define PH_DEFAULT_REAGENT_PUMP_TIME 2 // время работы подачи реагента по умолчанию, для изменения pH на 0.1, секунд

#define PH_MV_PER_7_PH 2000 // кол-во милливольт, при  которых датчик показывает 7 pH

// раскомментировать следующую инструкцию #define, если датчик pH имеет реверсивное изменение вольтажа при изменении pH,
// т.е. если при увеличении pH значение вольтажа в порту контроллера уменьшается. По умолчанию считается, что при увеличении pH
// значение вольтажа в порту контроллера увеличивается.
// #define PH_REVERSIVE_MEASURE 

#define PH_CONTROL_CHECK_INTERVAL 10000 // через сколько миллисекунд контролировать значение pH на предмет попадания в эталонный диапазон

#define PH_FLOW_LEVEL_SENSOR_CHANNEL 0 // номер канала микросхемы PCF8574, на который заведён сигнал с датчика уровня воды
#define PH_FLOW_LEVEL_TRIGGERED HIGH // уровень, при котором датчик уровня воды считается сработавшим

#define PH_FLOW_ADD_CHANNEL 1 // номер канала микросхемы PCF8574 для включения клапана подачи воды
#define PH_FLOW_ADD_OFF LOW // уровень, при котором клапан подачи воды выключен
#define PH_FLOW_ADD_ON HIGH // уровень, при котором клапан подачи воды включен

#define PH_PLUS_CHANNEL 2 // номер канала микросхемы PCF8574 для повышения уровня pH
#define PH_MINUS_CHANNEL 3 // номер канала микросхемы PCF8574 для понижения уровня pH
#define PH_CONTROL_VALVE_ON HIGH // уровень, включающий клапан поправочного раствора
#define PH_CONTROL_VALVE_OFF LOW // уровень, выключающий клапан поправочного раствора

#define PH_MIX_PUMP_CHANNEL 4 // номер канала микросхемы PCF8574 для насоса перемешивания раствора
#define PH_MIX_PUMP_ON HIGH // уровень для включения насоса перемешивания раствора
#define PH_MIX_PUMP_OFF LOW // уровень для выключения насоса перемешивания раствора

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля датчиков влажности почвы (актуально при раскомментированной команде USE_SOIL_MOISTURE_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define FREQUENCY_SOIL_MOISTURE 1 // частотный датчик влажности почвы
#define ANALOG_SOIL_MOISTURE 2 // аналоговый датчик влажности почвы

//--------------------------------------------------------------------------------------------------------------------------------
#define SUPPORTED_SOIL_MOISTURE_SENSORS 1 // кол-во проводных датчиков влажности почвы

// ДЛЯ ПЛАТЫ ВЫВОДЫ ДАТЧИКОВ ВЛАЖНОСТИ ПОЧВЫ - A2, A3 
#define SOIL_MOISTURE_SENSORS {A2, FREQUENCY_SOIL_MOISTURE}//,{A3, ANALOG_SOIL_MOISTURE} // АНАЛОГОВЫЕ пины, на которых сидят датчики влажности почвы (через запятую, кол-во равно SUPPORTED_SOIL_MOISTURE_SENSORS!)

#define SOIL_MOISTURE_UPDATE_INTERVAL 10000 // через сколько мс обновлять показания с датчиков влажности почвы
#define SOIL_MOISTURE_100_PERCENT 450 // какие показания analogRead соответствуют датчику, погруженному в воду
#define SOIL_MOISTURE_0_PERCENT 1023 // какие показания analogRead соответствуют датчику на воздухе, т.е. полностью сухой почве 

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля влажности (актуально при раскомментированной команде USE_HUMIDITY_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define H_SENSOR(pin,pin2,type) { (pin) , (pin2), (type) } // для удобства добавления сенсора в массив
// типы поддерживаемых сенсоров: DHT11, DHT2x, SI7021, SHT10
#define SUPPORTED_HUMIDITY_SENSORS 2 // кол-во поддерживаемых проводных датчиков влажности
// описание поддерживаемых датчиков влажности, через запятую, кол-вом SUPPORTED_HUMIDITY_SENSORS.
// формат: H_SENSOR(пин1, пин2, тип)
// где: пин1 - первый пин, на котором висит датчик
// пин2 - второй пин, на котором висит датчик.
// в случае I2C-датчика значения обоих пинов - 0
// в случае датчика, использующего одну линию (например, DHT*) - первый пин - линия данных, второй пин - 0
// два пина используются только SHT10: первый пин - данные (data pin), второй - строб (clock pin)
// следующий после первого датчик добавляется через запятую.
// Примеры:
// для одного датчика:
// #define HUMIDITY_SENSORS H_SENSOR(12,0,DHT2x)
// для двух и более датчиков:
// #define HUMIDITY_SENSORS H_SENSOR(12,0,DHT2x), H_SENSOR(14,0,DHT11), H_SENSOR(15,0,DHT2x)
// ДЛЯ ПЛАТЫ НОМЕРА ВЫВОДОВ ДЛЯ ДВУХ DHT - A6,A7 !!!
#define HUMIDITY_SENSORS H_SENSOR(0,0,SI7021), H_SENSOR(A7,0,DHT2x)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля температур/управления фрамугами (актуально при раскомментированной команде USE_TEMP_SENSORS)
//--------------------------------------------------------------------------------------------------------------------------------
#define DEF_OPEN_INTERVAL 30000 // по умолчанию 30 секунд работы мотора на полное открытие/закрытие фрамуги
#define DEF_OPEN_TEMP 25 // температура открытия по умолчанию, градусов Цельсия
#define DEF_CLOSE_TEMP 24 // температура закрытия по умолчанию, градусов Цельсия
#define SUPPORTED_SENSORS 1 // кол-во поддерживаемых проводных датчиков температуры, подсоединённых к контроллеру
#define ADD_T(pin,type) {(pin),(type)} // для добавления сенсора в массив

// поддерживаемые типы датчиков температуры: DS18B20 и DS18S20
// для добавления датчика температуры используйте конструкцию ADD_T,
// например, ADD_T(22,DS18S20) добавляет датчик типа DS18S20 на 22-й пин
// ДЛЯ ПЛАТЫ ВЫВОДЫ ПО УМОЛЧАНИЮ, ПОДТЯНУТЫЕ РЕЗИСТОРАМИ - A11, A12, A13
#define TEMP_SENSORS_PINS ADD_T(A11,DS18B20)//, ADD_T(32,DS18B20) // пины, на которых висят наши датчики температуры (указываются через запятую, общее кол-во равно SUPPORTED_SENSORS)

#define SUPPORTED_WINDOWS 4 // кол-во поддерживаемых окон, максимум 16 (по два реле на мотор, для 8-ми канального модуля реле - 4 окна)
// пины реле управления фрамугами (попарно, через запятую!) На каждом пине висит одно реле, пара реле (например,
// 40 и 41) образуют одну пару управления DC-мотором. Кол-во реле равно SUPPORTED_WINDOWS*2, соответственно, кол-во используемых
// пинов - всегда чётно! Поэтому будьте внимательны при редактировании этой настройки!
// Как подключается мотор: контакты двигателя подключаются к общим (COM) контактам пары реле.
// Плюс питания - к NO (нормально разомкнутым контактам пары реле).
// Минус питания - к NC (нормально замкнутым контактам реле).

//--------------------------------------------------------------------------------------------------------------------------------
// Настройки пинов управления фрамугами (актуально при раскомментированной команде USE_TEMP_SENSORS)
//--------------------------------------------------------------------------------------------------------------------------------
// если USE_WINDOWS_SHIFT_REGISTER не определена (закомментирована выше) - через эти пины будут управляться реле
// КОЛ-ВО ПИНОВ РАВНО SUPPORTED_WINDOWS*2 !!! БУДЬТЕ ВНИМАТЕЛЬНЫ !!!
// ниже указан пример для управления четырьмя окнами напрямую, т.е. - 8 пинов
#define WINDOWS_RELAYS_PINS 40,41,42,43,44,45,46,47 

// Если USE_WINDOWS_SHIFT_REGISTER определена (раскомментирована выше) - управление окнами пойдёт через сдвиговый регистр 74HC595 по пинам, указанным ниже
#define WINDOWS_SHIFT_LATCH_PIN 40 // пин защёлки (нога ST_CP регистра)
#define WINDOWS_SHIFT_DATA_PIN 41 // пин данных (нога DS регистра)
#define WINDOWS_SHIFT_CLOCK_PIN  42 // пин тактирования (нога SH_CP регистра)
#define WINDOWS_SHIFT_OE_PIN 43 // пин, который управляет ногой OE регистра (должен быть подтянут к питанию резистором на 10К) 

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления поливом (актуально при раскомментированной команде USE_WATERING_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// режимы управления пинами - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_DRIVE_MODE DRIVE_DIRECT // прямое управление пинами, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим каналами полива (если управление в режиме DRIVE_MCP23S17)
#define WATER_MCP23S17_ADDRESS 0

// адрес микросхемы MCP23017, через которую рулим каналами полива (если управление в режиме DRIVE_MCP23017)
#define WATER_MCP23017_ADDRESS 4 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// как управляем пином насоса (актуально при раскомментированной команде USE_PUMP_RELAY)
// режимы управления пинами -  [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_PUMP_DRIVE_MODE DRIVE_DIRECT // прямое управление пином, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23S17)
#define WATER_PUMP_MCP23S17_ADDRESS 0

// адрес микросхемы MCP23017, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23017)
#define WATER_PUMP_MCP23017_ADDRESS 4 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// пин, на котором сидит реле управления насосом:
// 1. Для прямого управления пинами (DRIVE_DIRECT - номер пина)
// 2. Для управления через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define PUMP_RELAY_PIN 22

// настройки второго насоса (актуально при раскомментированной команде USE_SECOND_PUMP)
// как управляем пином второго насоса
// режимы управления пинами - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_PUMP2_DRIVE_MODE DRIVE_DIRECT // прямое управление пином, также можно рулить через расширители портов (MCP23S17 и MCP23017)

// адрес микросхемы MCP23S17, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23S17)
#define WATER_PUMP2_MCP23S17_ADDRESS 0

// адрес микросхемы MCP23017, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23017)
#define WATER_PUMP2_MCP23017_ADDRESS 4 // 0 - первая микросхема по адресу 0x20, 1 - вторая по адресу 0x21 и т.п.

// пин, на котором висит второй насос:
// 1. Для прямого управления пинами (DRIVE_DIRECT - номер пина)
// 2. Для управления через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define SECOND_PUMP_RELAY_PIN 22

 // с какого канала полива включать второй насос. Если используем второй насос, то можно первый насос включать
 // для первой половины каналов, второй насос - для второй половины каналов.
 // Например, если кол-во каналов - 4, и в этой настройке указано 2, то
 // для каналов 2 и больше (т.е. 2 и 3, нумерация каналов идёт с нуля) - будет включаться второй насос
 #define SECOND_PUMP_START_CHANNEL 2

// уровни для реле каналов полива
#define WATER_RELAY_ON LOW // уровень для включения реле
#define WATER_RELAY_OFF HIGH // уровень для выключения реле

// уровни для реле насоса
#define WATER_PUMP_RELAY_ON LOW // уровень для включения реле
#define WATER_PUMP_RELAY_OFF HIGH // уровень для выключения реле

#define WATER_RELAYS_COUNT 4 // сколько каналов управления поливом используется (максимум - 16)

// объявляем пины для управления каналами реле - дописывать в этот массив, через запятую,
// кол-во равно WATER_RELAYS_COUNT!
// ДЛЯ ПЛАТЫ НОМЕРА ВЫВОДОВ КОНТРОЛЯ КАНАЛОВ ПОЛИВА - 23,24,25,27
// При прямом управлении пинами - номера пинов, при управлении через DRIVE_MCP23S17 и DRIVE_MCP23017 - номер канала микросхемы
#define WATER_RELAYS_PINS 23,24,25,27 

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля LCD 128х64 на базе контроллера ST7920 (актуально при раскомментированной команде USE_LCD_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// определяем пины, на которых сидит экран
// подключение:
// пин BLA дисплея идёт на пин управления подсветкой
// пин BLK дисплея идёт на GND
// пин PSB дисплея идёт на GND
// пины GND и VCC дисплея - тут всё ясно
// пин E дисплея идёт на SCREEN_SCK_PIN (программный SPI), или - на хардварный SCK пин микроконтроллера (аппаратный SPI)
// пин R/W дисплея идёт на SCREEN_MOSI_PIN (программный SPI), или - на хардварный MOSI микроконтроллера (аппаратный SPI)
// пин RS дисплея - идёт на SCREEN_CS_PIN, это линия chip select, для выбора ведомого

//#define SCREEN_USE_SOFT_SPI // раскомментировать, если нужен режим программного SPI
#define SCREEN_SCK_PIN 52 // пин SCK, актуален для режима программного SPI (в режиме железного SPI используются соответствующий пин SCK микроконтроллера)
#define SCREEN_MOSI_PIN 51 // пин MOSI, актуален для режима программного SPI (в режиме железного SPI используются соответствующий пин MOSI микроконтроллера)
#define SCREEN_CS_PIN 4 // пин CS
#define SCREEN_BACKLIGHT_PIN 5 // номер пина, на котором будет управление подсветкой (пин с ШИМ !!!)
#define SCREEN_BACKLIGHT_INTENSITY 120 // яркость подсветки (0-255), управляется ШИМ на соответствующем пине (SCREEN_BACKLIGHT_PIN)
#define SCREEN_BACKLIGHT_OFF_DELAY 15000 // через сколько мс выключать подсветку дисплея после перехода в экран ожидания
#define MENU_RESET_DELAY 8000 // через сколько мс, если ничего не сделано, переключаться в экран ожидания
//#define FLIP_SCREEN // повернуть ли экран на 180 градусов при старте (закомментировать, если этого не надо)
//#define SCREEN_HINT_AT_RIGHT //раcкомментировать, если надо выравнивать подсказку выбранного экрана по правой стороне

#define WATER_CHANNELS_SCREEN_ENABLED // закомментировать, если не нужен экран управления отдельными каналами полива
#define WINDOWS_CHANNELS_SCREEN_ENABLED  // закомментировать, если не нужен экран управления отдельными каналами окон
#define SENSORS_SETTINGS_ON_SD_ENABLED // закомментировать, если не нужно читать настройки датчиков экрана ожидания с SD-карты
/*
 Принцип простой: если SENSORS_SETTINGS_ON_SD_ENABLED раскомментирована и на SD-карте есть настройки датчиков - мы читаем и выводим с них,
 в противном случае - деградируем на вшитые настройки WAIT_SCREEN_SENSORS, которые описаны ниже
 */

// настройки кнопки для меню
#define MENU_BUTTON_PIN A10 // пин, на котором висит кнопка перехода внутрь экрана и выбора между параметрами
// кнопка подключается так:
// пин подтянут к питанию резистором на 10К - и соединён с кнопкой
// второй контакт кнопки - к земле. Керамика - желательна.

// настройки энкодера
// энкодер подключается так: средний вывод - к питанию.
// левый и правый - к пинам, дополнительно притянуты к земле резисторами на 10К
#define ENCODER_A_PIN A0 // пин МК, на котором сигнал с левой ноги энкодера
#define ENCODER_B_PIN A1 // пин МК, на котором сигнал с правой ноги энкодера
#define ENCODER_PULSES_PER_CLICK 20 // сколько импульсов приходится на один клик энкодера, подбирать опытным путём, для удобства

// настройки экрана ожидания
#define ROTATION_INTERVAL 7000 // через сколько мс менять на экране ожидания показания с датчиков
#define W_S(type,index, module, displayName) {(type),(index),(module),(displayName) }
// на экране ожидания можно выводить N показаний любых поддерживаемых системой датчиков.
// для добавления показаний с датчика используйте конструкцию W_S.
// показания добавляются в WAIT_SCREEN_SENSORS, через запятую, например:
// добавляем на экран ожидания показания температурного датчика с индексом 0
// модуля STATE:  W_S(StateTemperature,0,"STATE","Tнаруж")
// Пример для нескольких датчиков:
// #define WAIT_SCREEN_SENSORS W_S(StateTemperature,0,"STATE","Твнутр") ,W_S(StateTemperature,1,"STATE","Tнаруж") ,W_S(StateLuminosity,0,"LIGHT","свет") ,W_S(StateHumidity,0,"HUMIDITY","влажность")
// типы показаний: StateTemperature - температура, StateLuminosity - освещенность, StateHumidity - влажность, StateSoilMoisture - влажность почвы, StatePH - значение pH

// определяем вид экрана ожидания тут
#define WAIT_SCREEN_SENSORS W_S(StateSoilMoisture,0,"SOIL","Почва"), W_S(StateSoilMoisture,1,"SOIL","Почва модуль"), W_S(StateTemperature,0,"STATE","T внутри") ,W_S(StateHumidity,0,"HUMIDITY","Влажность") ,W_S(StateLuminosity,0,"LIGHT","Освещенность")


//--------------------------------------------------------------------------------------------------------------------------------
// Настройки W5100 (актуально при раскомментированной команде USE_W5100_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define W5100_REBOOT_PIN 44 // номер пина, на котором будет управление питанием W5100 - пока реализовано только включение (актуально при раскомментированной команде USE_W5100_REBOOT_PIN)
#define W5100_POWER_OFF LOW // уровень для выключения питания
#define W5100_POWER_ON HIGH // уровень для включения питания

//--------------------------------------------------------------------------------------------------------------------------------
// Настройки Nextion (актуально при раскомментированной команде USE_NEXTION_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define NEXTION_SERIAL Serial3 // какой Serial используем для Nextion (ВНИМАНИЕ! Если используется RS-485 - Nextion по умолчанию сидит на этом же Serial, конфликт!)
#define NEXTION_BAUD_RATE 9600 // скорость обмена командами с дисплеем
#define NEXTION_SLEEP_DELAY 60 // через сколько секунд переходить в сон, если ничего не сделано на экране
#define NEXTION_WAIT_TIMER 10000 // интервал таймера переключения на экран ожидания, мс
#define NEXTION_ROTATION_INTERVAL 7000 // через сколько мс менять на экране ожидания показания с датчиков

// настройки экрана ожидания
#define NW_S(type,index, module) {(type),(index),(module)}
// на экране ожидания можно выводить N показаний любых поддерживаемых системой датчиков.
// для добавления показаний с датчика используйте конструкцию NW_S.
// показания добавляются в NEXTION_WAIT_SCREEN_SENSORS, через запятую, например:
// добавляем на экран ожидания показания температурного датчика с индексом 0
// модуля STATE:  NW_S(StateTemperature,0,"STATE")
// Пример для нескольких датчиков:
// #define NEXTION_WAIT_SCREEN_SENSORS NW_S(StateTemperature,0,"STATE") ,NW_S(StateTemperature,1,"STATE") ,NW_S(StateLuminosity,0,"LIGHT") ,NW_S(StateHumidity,0,"HUMIDITY")
// типы показаний: StateTemperature - температура, StateLuminosity - освещенность, StateHumidity - влажность.
// На текущий момент Nextion подддерживает вывод только этих типов датчиков, поскольку выводит подписи к типу датчика картинками,
// следовательно - надо менять файл проекта для Nextion. Если вы читаете эти строки и вам необходима такое усовершенствование - 
// дайте мне знать, и я постараюсь добавить этот функционал.

// определяем вид экрана ожидания тут
#define NEXTION_WAIT_SCREEN_SENSORS NW_S(StateTemperature,0,"STATE") ,NW_S(StateHumidity,1,"HUMIDITY") ,NW_S(StateLuminosity,0,"LIGHT")

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля учёта воды (актуально при раскомментированной команде USE_WATERFLOW_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// модуль занимает пины 2 и 3 меги, т.к. работает по прерываниям.
// поддерживаемые типы датчиков - китайские water flow meter с датчиком Холла.
// подключение простое: питание, земля, линию данных - на пин 2 для первого датчика, на пин 3 - для второго датчика.
#define WATERFLOW_SENSORS_COUNT 2 // доступные значения: 0, 1, 2. Если 0 - никакие показания сниматься не будут, следовательно, пины 2 и 3 останутся свободны
#define WATERFLOW_SAVE_DELTA 10 // через сколько накопленных литров сохранять в EEPROM значение с датчика

// сколько пульсаций в секунду выдаёт датчик при протекании литра за минуту - 
// калибровочное значение, если не совпадает с реальным расходом - подбирать!
#define WATERFLOW_CALIBRATION_FACTOR 45 // фактор калибровки по умолчанию, можно потом менять через конфигуратор

#define WATERFLOW_CHECK_FREQUENCY 2000 // через сколько мс обновлять показания с датчиков расхода


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления по SMS (модем NEOWAY M590 или SIM800L) (актуально при раскомментированной команде USE_SMS_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define GSM_SERIAL Serial1 // какой хардварный Serial будем использовать при работе с модемом?
#define GSM_EVENT_FUNC serialEvent1 // функция для обработки событий входящего трафика для модуля
#define GSM_BAUDRATE 57600 // скорость работы с GSM-модемом
#define GSM_AVAILABLE_CHECK_TIME 60000 // через сколько миллисекунд проверять доступность модема посылкой команды AT
#define GSM_WAIT_BOOT_TIME 2000 // сколько мс ждать загрузки модема
#define GSM_CHECK_REGISTRATION_INTERVAL 4567 // через сколько мс проверять регистрацию в сети (повторные вызовы с указанным промежутком до тех пор, пока модем не зарегистрируется)
#define GSM_REBOOT_TIME 2000 // сколько миллисекунд держать питание выключенным при перезагрузке модема, если он завис
#define GSM_WAIT_AFTER_REBOOT_TIME 5000 // сколько мс ждать после перезагрузки модема прежде, чем начать обрабатывать команды
#define GSM_MAX_ANSWER_TIME 60000 // через сколько мс, если не получен ответ на команду от модема, считать его зависшим
#define GSM_REBOOT_PIN 12 // номер пина, на котором будет управление питанием GSM-модема (актуально при раскомментированной команде USE_GSM_REBOOT_PIN)
#define GSM_POWER_OFF LOW // уровень для выключения питания
#define GSM_POWER_ON HIGH // уровень для включения питания

// настройки команд запроса баланса для разных операторов
#define TELE2_BALANCE F("*105#") // команда для проверки баланса Tele2 (баланс отсылается хозяину по приходу на контроллер СМС с текстом "#5" или выполнению команды CTGET=SMS|BAL.
#define BEELINE_BALANCE F("*102#") // Билайн
#define MTS_BALANCE F("*100#") // МТС
#define MEGAFON_BALANCE F("*100#") // Мегафон
#define YOTA_BALANCE F("*100#") // Йота
#define MTS_BEL_BALANCE F("*100#") // МТС Беларусь
#define VELCOM_BEL_BALANCE F("*100#") // Velcom Беларусь
#define PRIVET_BEL_BALANCE F("*120#") // Privet Беларусь
#define LIFE_BEL_BALANCE F("*100#") // Life Беларусь

// настройки GPRS разных операторов
// Билайн
#define BEELINE_APN F("internet.beeline.ru")
#define BEELINE_USER F("beeline")
#define BEELINE_PASS F("beeline")

// МТС
#define MTS_APN F("internet.mts.ru")
#define MTS_USER F("mts")
#define MTS_PASS F("mts")

// Мегафон
#define MEGAFON_APN F("internet")
#define MEGAFON_USER F("gdata")
#define MEGAFON_PASS F("gdata")

// Теле2
#define TELE2_APN F("internet.tele2.ru")
#define TELE2_USER F("")
#define TELE2_PASS F("")

// Йота
#define YOTA_APN F("internet.yota")
#define YOTA_USER F("")
#define YOTA_PASS F("")

// МТС Беларусь
#define MTS_BEL_APN F("mts")
#define MTS_BEL_USER F("mts")
#define MTS_BEL_PASS F("mts")

// Velcom Беларусь
#define VELCOM_BEL_APN F("vmi.velcom.by")
#define VELCOM_BEL_USER F("")
#define VELCOM_BEL_PASS F("")

// Privet Беларусь
#define PRIVET_BEL_APN F("wap.privet.by")
#define PRIVET_BEL_USER F("")
#define PRIVET_BEL_PASS F("")

// Life Беларусь
#define LIFE_BEL_APN F("internet.life.com.by")
#define LIFE_BEL_USER F("")
#define LIFE_BEL_PASS F("")

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля WI-FI (актуально при раскомментированной команде USE_WIFI_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define WIFI_SERIAL Serial2 // какой хардварный сериал использовать для WI-FI?
#define WIFI_EVENT_FUNC serialEvent2 // функция для обработки событий входящего трафика от модуля
#define WIFI_BAUDRATE 115200 // скорость работы с UART для WI-FI
#define WIFI_TCP_KEEP_ALIVE // не разрывать соединение после отсыла ответа
#define STATION_ID F("TEPLICA") // ID точки доступа, которую создаёт модуль WI-FI
#define STATION_PASSWORD F("12345678") // пароль к точке доступа, которую создаёт вай-фай (МИНИМУМ 8 СИМВОЛОВ, ИНАЧЕН НЕ БУДЕТ РАБОТАТЬ!)
#define ROUTER_ID F("")  // SSID домашнего роутера, к которому коннектится модуль WI-FI
#define ROUTER_PASSWORD F("") // пароль к домашнему роутеру, к которому коннектится модуль WI-FI

#define WIFI_AVAILABLE_CHECK_TIME 60000 // через сколько миллисекунд проверять доступность ESP посылкой команды AT
#define WIFI_REBOOT_TIME 2000 // сколько миллисекунд держать питание выключенным при перезагрузке ESP, если он завис
#define WIFI_WAIT_BOOT_TIME 2000 // сколько мс ждать загрузки модема
#define WIFI_WAIT_AFTER_REBOOT_TIME 5000 // сколько мс ждать после перезагрузки ESP прежде, чем начать обрабатывать команды
#define WIFI_MAX_ANSWER_TIME 30000 // через сколько мс, если не получен ответ на команду от модема, считать его зависшим
#define WIFI_REBOOT_PIN 11 // номер пина, на котором будет управление питанием GSM-модема (актуально при раскомментированной команде USE_WIFI_REBOOT_PIN)
#define WIFI_POWER_OFF LOW // уровень для выключения питания
#define WIFI_POWER_ON HIGH // уровень для включения питания

//--------------------------------------------------------------------------------------------------------------------------------
// настройки IoT (актуально при раскомментированной команде USE_IOT_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define IOT_USER_AGENT F("greenhouse") // User-agent для запроса
#define THINGSPEAK_IP F("184.106.153.149") // IP сервиса ThingSpeak
#define THINGSPEAK_HOST F("api.thingspeak.com") // Имя хоста ThingSpeak
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
// Настройки модуля запроса команд к контроллеру по HTTP (актуально при раскомментированной команде USE_HTTP_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------

#define HTTP_SERVER_IP "gardenboss.ru"    //"192.168.1.33" // адрес хоста, который мы опрашиваем на команды (IP или доменное имя)
#define HTTP_SERVER_HOST "gardenboss.ru"  //"gh-local.ru" // имя хоста (для заголовка Host)
#define HTTP_POLL_INTERVAL 300 // через сколько секунд проверять на команды (минимум - 300 секунд, т.е. 5 минут)


//--------------------------------------------------------------------------------------------------------------------------------
// настройки тревог (актуально при раскомментированной команде USE_ALARM_DISPATCHER)
//--------------------------------------------------------------------------------------------------------------------------------
#define ALARM_SMS_TEXT F("Тревога! Сработало правило: ") // текст СМС, который отправится при срабатывании тевожного правила, к СМС будет добавлено имя правила
//#define CLEAR_ALARM_STATUS // раскомментировать, если надо очищать сработавшие тревоги через указанный ниже промежуток времени. 
//Если тревоги не очищаются - SMS посылается однократно, до перезагрузки контроллера
#define ALARM_CLEAR_INTERVAL 10 // интервал между очистками сработавших тревог, в минутах


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// \/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// !!! СЛУЖЕБНЫЕ НАСТРОЙКИ - МЕНЯЕМ, ЕСЛИ ПОНИМАЕМ, ДЛЯ ЧЕГО И ЗАЧЕМ !!!
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------------------------------------------------
// запрещаем использование более 16 каналов полива в прошивке (иначе не влезем в структуру состояния контроллера)
//--------------------------------------------------------------------------------------------------------------------------------
#if WATER_RELAYS_COUNT > 16
#error WATER CHANNELS IS LIMITED to 16 !!!
#endif
//--------------------------------------------------------------------------------------------------------------------------------
// запрещаем использование более 16 окон в прошивке (иначе не влезем в структуру состояния контроллера)
//--------------------------------------------------------------------------------------------------------------------------------
#if SUPPORTED_WINDOWS > 16
#error WINDOWS COUNT IS LIMITED to 16 !!!
#endif
//--------------------------------------------------------------------------------------------------------------------------------
// запрещаем использование более 8 каналов досветки в прошивке (иначе не влезем в структуру состояния контроллера)
//--------------------------------------------------------------------------------------------------------------------------------
#if LAMP_RELAYS_COUNT > 8
#error LAMP RELAYS COUNT IS LIMITED to 8 !!!
#endif
//--------------------------------------------------------------------------------------------------------------------------------
// запрещаем использование более одного шлюза в прошивке (ибо бессмысленно - два шлюза одновременно)
//--------------------------------------------------------------------------------------------------------------------------------
#if defined(USE_W5100_MODULE) && defined(USE_WIFI_MODULE)
#error PLEASE DONT USE BOTH ESP8266 AND W5100 MODULES !!!
#endif
//--------------------------------------------------------------------------------------------------------------------------------
// запрещаем использовать более одного дисплея в прошивке (ибо бессмысленно - два дисплея одновременно)
//--------------------------------------------------------------------------------------------------------------------------------
#if defined(USE_LCD_MODULE) && defined(USE_NEXTION_MODULE)
#error PLEASE DONT USE TWO OR MORE DISPLAYS !!!
#endif
//--------------------------------------------------------------------------------------------------------------------------------
// !!! ВСЕ НАСТРОЙКИ НИЖЕ - МЕНЯЕМ НА СВОЙ СТРАХ И РИСК, С ПОЛНЫМ ПОНИМАНИЕМ ТОГО, ЧТО ХОТИМ СДЕЛАТЬ !!! ЕСЛИ ЧТО - КАЖДЫЙ ССЗБ, Я ПРЕДУПРЕДИЛ.
//--------------------------------------------------------------------------------------------------------------------------------

//#define _DEBUG // отладочный режим (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define WIFI_DEBUG // режим отладки Wi-Fi-модуля (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define GSM_DEBUG_MODE // режим отладки SMS-модуля (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define LOGGING_DEBUG_MODE // раскомментировать для отладочного режима (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define LCD_DEBUG // отладочный режим LCD-модуля (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define ETHERNET_DEBUG // отладочный режим Ethernet-модуля (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define WATER_DEBUG // отладочный режим модуля полива (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define NRF_DEBUG // отладочный режим nRF, (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define RS485_DEBUG // отладочный режим RS-485, (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define UNI_DEBUG // отладочный режим универсальных модулей (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define PH_DEBUG // раскомментировать для отладочного режима (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define IOT_UNIT_TEST // режим юнит-тестирования IoT-функционала, не раскомментировать без понимания того, что делаем.
//#define HTTP_DEBUG // отладочный режим провайдеров HTTP-запросов, как правило - надо включать совместно с WIFI_DEBUG (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки максимумов
//--------------------------------------------------------------------------------------------------------------------------------
#define MAX_ARGS_IN_LIST 20 // максимальное кол-во аргументов у команды, передаваемой контроллеру по UART
#define MAX_RECEIVE_BUFFER_LENGTH 256 // максимальная длина (в байтах) пакета в сети, дла защиты от спама

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля алертов (событий по срабатыванию каких-либо условий)
//--------------------------------------------------------------------------------------------------------------------------------
#define ALERT F("ALERT") // произошло событие
#define VIEW_COMMAND F("VIEW") // команда просмотра события CTGET=ALERT|VIEW|0
#define CNT_COMMAND F("CNT") // сколько зарегистрировано событий CTGET=ALERT|CNT
// правило алерта CTSET=ALERT|RULE_ADD|RuleName|STATE|TEMP|1|>|23|Время начала работы|Продолжительность работы, мин|Маска дней недели|Список связанных правил|Команды для стороннего модуля
// пример №1: CTSET=ALERT|RULE_ADD|N1|STATE|TEMP|1|>|23|0|30|127|N3,N4|CTSET=STATE|WINDOW|ALL|OPEN
// пример №2: CTSET=ALERT|RULE_ADD|N1|STATE|TEMP|1|>|23|0|0|127|_|CTSET=STATE|WINDOW|ALL|OPEN
#define ADD_RULE F("RULE_ADD") // добавить правило
#define RULE_CNT F("RULES_CNT") // кол-во правил CTGET=ALERT|RULES_CNT
#define RULE_VIEW F("RULE_VIEW") // просмотр правила по индексу CTGET=ALERT|RULE_VIEW|0
#define RULE_STATE F("RULE_STATE") // включить/выключить правило по имени CTSET=ALERT|RULE_STATE|RuleName|ON, CTSET=ALERT|RULE_STATE|RuleName|OFF, CTSET=ALERT|RULE_STATE|ALL|OFF
#define RULE_ALERT F("RULE_ALERT")
// получить состояние правила по индексу -  CTGET=ALERT|RULE_STATE|0

#define RULE_DELETE F("RULE_DELETE") // удалить правило по имени CTSET=ALERT|RULE_DELETE|RuleName - ПРИ УДАЛЕНИИ ВСЕ ПРАВИЛА СДВИГАЮТСЯ К ГОЛОВЕ ОТ УДАЛЁННОГО !!! 
// Специальный параметр ALL (CTSET=ALERT|RULE_DELETE|ALL) удаляет все правила.

#define SAVE_RULES F("SAVE") // команда "сохранить правила", CTSET=ALERT|SAVE
#define GREATER_THAN F(">") // больше чем
#define GREATER_OR_EQUAL_THAN F(">=") // больше либо равно
#define LESS_THAN F("<") // меньше чем
#define LESS_OR_EQUAL_THAN F("<=") // меньше или равно
#define T_OPEN_MACRO F("%TO%") // макроподстановка температуры открытия из настроек
#define T_CLOSE_MACRO F("%TC%") // макроподстановка температуры закрытия из настроек


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля логгирования информации
//--------------------------------------------------------------------------------------------------------------------------------
//#define ADD_LOG_HEADER // закомментировать, если не надо добавлять первые строки с информацией, с каких модулей есть данные).
// Первая строка информации имеет вид:
// MODULE_NAME1=MODULE_IDX1,MODULE_NAME2=MODULE_IDX2,MODULE_NAMEn=MODULE_IDXn
// где MODULE_NAMEn - имя модуля, MODULE_IDXn = индекс модуля в системе.
// Вторая строка информации сообщает о типах датчиков, и имеет вид:
// TYPE1=IDX1,TYPEn=IDXn
// где TYPEn - название типа (например, TEMP для температуры), IDXn - числовое представление типа.
//#define LOG_CNANGE_NAME_TO_IDX // раскомментировать, если нужен лог меньшего размера.
// в этом случае в каждой строке вместо имени модуля подставляется его индекс в системе. 
//#define LOG_CHANGE_TYPE_TO_IDX // раскомментировать, если нужен лог меньшего размера.
// в этом случае в каждой строке вместо названия типа датчика подставляется его индекс в системе.
//#define WRITE_ABSENT_SENSORS_DATA // раскомментировать, если надо писать показания датчика, даже если показаний с него нет
#define LOG_TEMP_TYPE F("RT") // тип для температуры, который запишется в файл
#define LOG_HUMIDITY_TYPE F("RH") // тип для влажности, который запишется в файл
#define LOG_LUMINOSITY_TYPE F("RL") // тип для освещенности, который запишется в файл
#define LOG_WATERFLOW_TYPE F("WF") // тип для датчика расхода воды, который запишется в файл
#define LOG_SOIL_TYPE F("SM") // тип для датчика влажности почвы, который запишется в файл
#define LOG_PH_TYPE F("PH") // тип для датчика pH, который запишется в файл
#define COMMA_DELIMITER F(",") // разделитель полей в CSV
#define LOGS_DIRECTORY F("logs") // название папки с логами на карточке
#define ACTIONS_DIRECTORY F("actions") // название папки с логами действий на карточке
#define END_OF_FILE F("END_OF_FILE") // какую строку посылаем, когда весь файл вычитали
#define FOLLOW F("FOLLOW") // ответ, что файл будет выслан следующими строками
#define FILE_COMMAND F("FILE") // получить данные с файла
#define ACTIONS_COMAND F("ACTION") // получить данные с файла действий


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля освещенности
//--------------------------------------------------------------------------------------------------------------------------------
#define LIGHT_STATE_COMMAND F("STATE") // CTGET=LIGHT|STATE
#define NO_LUMINOSITY_DATA -1 // нет показаний с датчика освещенности (И ЭТУ КОНСТАНТУ НЕ ТРОГАЕМ, ДАЖЕ ЕСЛИ ОБКОЛОЛОСЬ УЖЕ ВСЁ !!!)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления фрамугами
//--------------------------------------------------------------------------------------------------------------------------------
#define STATE_OPENING F("OPENING") // Открывается
#define STATE_CLOSING F("CLOSING") // Закрывается
#define STATE_CLOSED F("CLOSED") // Закрыто
#define WM_AUTOMATIC F("AUTO") // автоматический режим управления фрамугами
#define WM_MANUAL F("MANUAL") // ручной режим управления фрамугами
#define WORK_MODE F("MODE") // получить/установить режим работы CTGET=STATE|MODE, CTSET=STATE|MODE|AUTO, CTSET=STATE|MODE|MANUAL
#define WM_INTERVAL F("INTERVAL") // получить/установить интервал на открытие/закрытие окон CTGET=STATE|INTERVAL, CTSET=STATE|INTERVAL|3000
#define STATE_OPEN F("OPEN") // Открыть CTSET=STATE|WINDOW|0|OPEN, CTSET=STATE|WINDOW|ALL|OPEN, CTSET=STATE|WINDOW|0-2|OPEN|2000
#define ALL F("ALL") // отработать все каналы
#define PROP_WINDOW F("WINDOW") // название канала, чтобы было понятно
#define PROP_WINDOW_CNT F("WINDOW_CNT") // кол-во фрамуг CTGET=STATE|WINDOW|WINDOW_CNT
#define PROP_WINDOW_STATEMASK F("STATEMASK") // CTGET=STATE|WINDOW|STATEMASK - получить состояние всех окон в виде маски. Ответ: OK=STATE|WINDOW|STATEMASK|Кол-во окон|Маска,
// где Маска - байты маски в виде шестнадцатеричной строки (например "F0"), для каждого окна в этих байтах - по два бита, их значение: 00 - закрыто, 01 - открывается, 10 - закрывается, 11 - открыто.
// например, для 4-х окон будет 1 байт (4*2 бита = 8 бит = 1 байт), для 5 окон - два байта, при этом во втором байте значащими будут только младшие 2 бита и т.д.
#define TEMP_SETTINGS F("T_SETT") // получить/установить температуры срабатывания, CTGET=STATE|T_SETT, CTSET=STATE|T_SETT|t open|t close
#define NO_TEMPERATURE_DATA -128 // нет данных с датчика температуры (ВООБЩЕ НЕ ТРОГАЕМ ЭТУ КОНСТАНТУ, ДАЖЕ ЕСЛИ ОЧЕНЬ КОЛЕТСЯ!!!)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления поливом
//--------------------------------------------------------------------------------------------------------------------------------
#define WATER_SETTINGS_COMMAND F("T_SETT") // получить/установить настройки управления поливом: CTGET=WATER|T_SETT, CTSET=WATER|T_SETT|WateringOption|WateringDays|WateringTime|StartTime|TurnOnPump , где
// WateringOption = 0 (выключено автоматическое управление поливом), 1 - автоматическое управление поливом включено (все каналы), 2 - автоуправление отдельно по каналам
// WateringDays - битовая маска дней недели (младший бит - понедельник и т.д.)
// WateringTime - продолжительность полива в минутах, максимальное значение - 65535 (два байта)
// StartTime - час начала полива (1 байт) - от 1 до 23
// TurnOnPump - включать (1) или нет (0) насос при активном поливе на любом из каналов
#define WATER_CHANNEL_SETTINGS F("CH_SETT") // получить/установить настройки отдельного канала управления поливом: CTGET=WATER|CH_SETT|0, CTSET=WATER|CH_SETT|0|WateringDays|WateringTime|StartTime
#define WATER_CHANNELS_COUNT_COMMAND F("CHANNELS") // получить кол-во поддерживаемых каналов полива: CTGET=WATER|CHANNELS

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля контроля воды
//--------------------------------------------------------------------------------------------------------------------------------
#define FLOW_CALIBRATION_COMMAND F("T_SETT") // получить/установить факторы калибровки: CTGET=FLOW|T_SETT, CTSET=FLOW|T_SETT|factor1|factor2

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля pH
//--------------------------------------------------------------------------------------------------------------------------------
#define PH_SETTINGS_COMMAND F("T_SETT") // получить/установить настройки: CTGET=PH|T_SETT, CTSET=PH|T_SETT|calibration_factor

//--------------------------------------------------------------------------------------------------------------------------------
// настройки главного контроллера
//--------------------------------------------------------------------------------------------------------------------------------
#define MIN_COMMAND_LENGTH 6 // минимальная длина правильной текстовой команды
#define CMD_PREFIX  F("CT") // запрос к контроллеру
#define CHILD_PREFIX F("CD") // запрос к дочернему модулю
#define CMD_PREFIX_LEN  2  // длина префикса команды

#define CMD_SET F("SET") // установить значение
#define CMD_GET F("GET") // получить значение
#define CMD_TYPE_LEN 3 // длина типа команды

//--------------------------------------------------------------------------------------------------------------------------------
#define READY F("READY") // будет напечатано в Serial после загрузки
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
// состояния вкл/выкл, для команд
//--------------------------------------------------------------------------------------------------------------------------------
#define STATE_ON F("ON") // Включено
#define STATE_ON_ALT F("1") // Включено
#define STATE_OFF F("OFF") // Выключено
#define STATE_OFF_ALT F("0") // Выключено

//--------------------------------------------------------------------------------------------------------------------------------
// ОТВЕТЫ ЗА ЗАПРОСЫ
//--------------------------------------------------------------------------------------------------------------------------------
#define OK_ANSWER F("OK") // ответ - всё ок
#define ERR_ANSWER F("ER") // ответ - ошибка
#define UNKNOWN_MODULE F("UNKNOWN_MODULE") // запрос к неизвестному модулю
#define PARAMS_MISSED F("PARAMS_MISSED") // пропущены параметры команды
#define UNKNOWN_COMMAND F("UNKNOWN_COMMAND") // неизвестная команда
#define NOT_SUPPORTED F("NOT_SUPPORTED") // не поддерживается

//--------------------------------------------------------------------------------------------------------------------------------
// РАЗДЕЛИТЕЛЬ ПАРАМЕТРОВ
//--------------------------------------------------------------------------------------------------------------------------------
#define PARAM_DELIMITER F("|")
//--------------------------------------------------------------------------------------------------------------------------------
// разделитель команды и ответа
//--------------------------------------------------------------------------------------------------------------------------------
#define COMMAND_DELIMITER F("=")

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля PIN
//--------------------------------------------------------------------------------------------------------------------------------
#define PIN_TOGGLE F("T") // CTGET=PIN|13, CTSET=PIN|13|1, CTSET=PIN|13|ON, CTSET=PIN|13|OFF, CTSET=PIN|13|0, CTSET=PIN|13|T
#define PIN_DETACH F("DETACH") // не устанавливать состояние пина

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля статистикм
//--------------------------------------------------------------------------------------------------------------------------------
#define FREERAM_COMMAND F("FREERAM") // показать кол-во свободной памяти CTGET=STAT|FREERAM
#define UPTIME_COMMAND F("UPTIME") // показать время работы (в секундах) CTGET=STAT|UPTIME
#ifdef USE_DS3231_REALTIME_CLOCK
#define CURDATETIME_COMMAND F("DATETIME") // вывести текущую дату и время CTGET=STAT|DATETIME
#endif

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления по SMS
//--------------------------------------------------------------------------------------------------------------------------------
#define STAT_COMMAND F("STAT") // получить текущую статистику по SMS, CTGET=SMS|STAT
#define BALANCE_COMMAND F("BAL") // получить баланс по SMS, CTGET=SMS|BAL
#define T_INDOOR F("Твн: ") // температура внутри
#define T_OUTDOOR F("Тнар: ") // температура снаружи
#define W_STATE F("Окна: ") // состояние окон
#define W_CLOSED F("закр") // закрыты
#define W_OPEN F("откр") // открыты
#define WTR_STATE F("Полив: ") // состояние полива
#define WTR_OFF F("выкл") // полив выкл
#define WTR_ON F("вкл") // полив вкл
#define SMS_OPEN_COMMAND F("#1") // открыть окна
#define SMS_CLOSE_COMMAND F("#0") // закрыть окна
#define SMS_STAT_COMMAND F("#9") // получить статистику
#define SMS_AUTOMODE_COMMAND F("#8") // установить автоматический режим работы
#define SMS_WATER_ON_COMMAND F("#4") // включить полив
#define SMS_WATER_OFF_COMMAND F("#6") // выключить полив
#define SMS_BALANCE_COMMAND F("#5") // получить баланс на счету
#define NO_DATA F("<нет данных>") // нет данных с датчика

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля WI-FI
//--------------------------------------------------------------------------------------------------------------------------------
#define WIFI_SETTINGS_COMMAND F("T_SETT") // установить настройки модуля: CTSET=WIFI|T_SETT|SHOULD_CONNECT_TO_ROUTER(0 or 1)|ROUTER_ID|ROUTER_PASS|STATION_ID|STATION_PASS
#define IP_COMMAND F("IP") // получить текущие IP-адреса, как самой точки доступа, так и назначенный роутером, CTGET=WIFI|IP
#define BUSY F("BUSY") // если мы не можем ответить на запрос - тогда возвращаем ER=WIFI|BUSY

// в дебаг-режиме переводим отладочный порт на такую же скорость, как и скорость
// порта, через который мы работаем с ESP
#ifdef WIFI_DEBUG
#undef SERIAL_BAUD_RATE
#define SERIAL_BAUD_RATE WIFI_BAUDRATE
#warning Serial BAUD RATE IS CHANGED TO WIFI_SERIAL BAUD RATE DUE TO WIFI_DEBUG MODE!
#endif

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля составных команд
//--------------------------------------------------------------------------------------------------------------------------------
#define CC_ADD_COMMAND F("ADD") // добавить составную команду, CTSET=CC|ADD|ListIndex|CommandAction|AdditionalParam
#define CC_SAVE_COMMAND F("SAVE") // сохранить все настройки составных команд в EEPROM, CTSET=CC|SAVE
#define CC_DELETE_COMMAND F("DEL") // удалить все составные команды, CTSET=CC|DEL
#define CC_PROCESS_COMMAND F("EXEC") // выполнить составную команду, CTSET=CC|EXEC|ListIndex


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля дельт
//--------------------------------------------------------------------------------------------------------------------------------
#define DELTA_ADD_COMMAND F("ADD") // добавить дельту, CTSET=DELTA|ADD|SensorType|ModuleName1|SensorIndex1|ModuleName2|SensorIndex2
#define DELTA_SAVE_COMMAND F("SAVE") // сохранить все настройки дельт в EEPROM, CTSET=DELTA|SAVE
#define DELTA_DELETE_COMMAND F("DEL") // удалить все дельты, CTSET=DELTA|DEL
#define DELTA_VIEW_COMMAND F("VIEW") // просмотр дельты по индексу, CTGET=DELTA|VIEW|0
#define DELTA_COUNT_COMMAND F("CNT") // получить кол-во сохранённых дельт, CTGET=DELTA|CNT

//--------------------------------------------------------------------------------------------------------------------------------
 // свойства модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define PROP_TEMP_CNT F("TEMP_CNT") // кол-во датчиков температуры CTGET=0|PROP|TEMP|TEMP_CNT, CTSET=0|PROP|TEMP|TEMP_CNT|2
#define PROP_RELAY_CNT F("RELAY_CNT") // кол-во каналов реле CTGET=0|PROP|MODULE_NAME|RELAY_CNT, CTSET=0|PROP|MODULE_NAME|RELAY_CNT|2
#define PROP_CNT F("CNT") // свойство - кол-во любых датчиков
#define PROP_TEMP F("TEMP") // нам передали/запросили температуру CTGET=0|PROP|MODULE_NAME|TEMP|0, CTSET=0|PROP|MODULE_NAME|TEMP|0|36,6
#define PROP_LIGHT F("LIGHT") // свойство "освещенность"
#define PROP_HUMIDITY F("HUMIDITY") // свойство "влажность"
#define PROP_PIN F("PIN") // свойство "пин" (для слежения за статусом пинов)
#define PROP_SOIL F("SOIL") // свойство "влажность почвы"
#define PROP_PH F("PH") // свойство pH
#define PROP_FLOW_INCREMENTAL F("AFLOW") // свойство "накопительный расход воды"
#define PROP_FLOW_INSTANT F("BFLOW") // свойство "мгновенный расход воды"
#define PROP_NONE F("_") // нет свойства

//--------------------------------------------------------------------------------------------------------------------------------
// команды модуля "0"
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_REMOTE_MODULES // раскомментировать, если нужна регистрация модулей на лету (при использовании сторонних железок, общающихся с контроллером)
#define NEWLINE F("\r\n")
#define SETTIME_COMMAND F("DATETIME") // установка даты/времени CTSET=0|DATETIME|DD.MM.YYYY hh:mm:ss
#define ADD_COMMAND F("ADD") // команда регистрации модуля CTSET=0|ADD|MODULE_NAME
#define PING_COMMAND F("PING") // команда пинга контроллера CTGET=0|PING
#define REGISTERED_MODULES_COMMAND F("LIST") // пролистать зарегистрированные модули CTGET=0|LIST
#define SMS_NUMBER_COMMAND F("PHONE") // сохранить/вернуть номер телефона для управления контроллером по СМС: CTSET=0|PHONE|+7918..., CTGET=0|PHONE
#define PONG F("PONG") // ответ на запрос пинга
#define REG_SUCC F("ADDED") // модуль зарегистрирован, или команда обработана
#define REG_DEL F("DELETED") // удалено
#define REG_ERR F("EXIST") // модуль уже зарегистрирован
#define UNKNOWN_PROPERTY F("UNKNOWN_PROPERTY") // неизвестное свойство
#define STATUS_COMMAND F("STAT") // получить статус внутренних состояний в виде закодированного пакета, CTGET=0|STAT
#define RESET_COMMAND F("RST") // перезагрузить контроллер
#define ID_COMMAND F("ID") // получить/установить ID контроллера
#define WIRED_COMMAND F("WIRED") // получить список кол-ва проводных датчиков, CTGET=0|WIRED (Температура|Влажность|Освещенность|Влажность почвы|PH)
#define UNI_COUNT_COMMAND F("UNI") // получить список кол-ва универсальных датчиков, CTGET=0|UNI (Температура|Влажность|Освещенность|Влажность почвы|PH)
#define UNI_NOT_FOUND F("U_NONE") // ответ на запрос CTGET=0|U_SEARCH, если универсального модуля не найдено
#define UNI_SEARCH F("U_SEARCH") // запрос CTGET=0|U_SEARCH, выдаёт информацию об универсальном модуле в формате OK=SCRATCHPAD_DATA и ERR=U_NONE, если датчика на линии нет
#define UNI_REGISTER F("U_REG") // запрос CTSET=0|U_REG|SCRATCHPAD_DATA, регистрирует подсоединённый к линии регистрации датчик, возвращает OK=ADDED, если датчик есть, и ERR=U_NONE, если датчика на линии нет
#define UNI_DIFFERENT_SCRATCHPAD F("SCRATCH_TYPE_ERROR") // ошибка при регистрации, разные типы скратчпада переданы
#define UNI_RF_CHANNEL_COMMAND F("RF") // команда на получение/установку канала для nRF
#define PINS_COMMAND F("PINS") // получить состояние пинов, CTGET=0|PINS, ответ OK=PINS|Кол-во_байт_в_пакете|HEX-пакет_занятых_пинов|HEX-пакет_режима_пинов
//--------------------------------------------------------------------------------------------------------------------------------
#define SD_BUFFER_LENGTH 128 // размер буфера для блочного чтения с SD
//--------------------------------------------------------------------------------------------------------------------------------
// общий буфер для команд
//--------------------------------------------------------------------------------------------------------------------------------
#define SHARED_BUFFER_LENGTH 200 // сколько байт резервировать для общего буфера обмена
#define WINDOWS_STATUS_BIT 0 // номер бита статуса окон (1 - открыты, 0 - закрыты)
#define WINDOWS_MODE_BIT 1 // номер бита режима работы окон (1 - авто, 0 - ручной)
#define WATER_STATUS_BIT 2 // номер бита статуса полива (1 - включен, 0 - выключен)
#define WATER_MODE_BIT 3 // номер бита режима работы полива (1 - авто, 0 - ручной)
#define LIGHT_STATUS_BIT 4 // номер бита состояния досветки (1 - включена, 0 - выключена)
#define LIGHT_MODE_BIT 5 // номер бита режима работы досветки (1 - авто, 0 - ручной)
#define WINDOWS_POS_CHANGED_BIT 6 // бит, выставленный в 1, если окна закончили смену позиции
#define PH_FLOW_ADD_BIT 7 // бит, выставляемый в 1, если насос заполнения бака pH включен
#define PH_MIX_PUMP_BIT 8 // бит, выставляемый в 1, если насос перемешивания pH работает
#define PH_PLUS_PUMP_BIT 9 // бит, выставляемый в 1, если насос повышения pH работает
#define PH_MINUS_PUMP_BIT 10 // бит, выставляемый в 1, если насос понижения pH работает
#define STATUSES_BYTES 2 // сколько байт под статусы у нас используется

#define SAVE_STATUS(bnum,sta) WORK_STATUS.SetStatus((bnum),(sta))

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля логгирования информации (актуально при раскомментированной команде USE_LOG_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
//#define LOG_ACTIONS_ENABLED // закомментировать, если не нужна запись действий на карту (например, события "включён полив" и т.п.)

//--------------------------------------------------------------------------------------------------------------------------------
// проверка целостности
//--------------------------------------------------------------------------------------------------------------------------------

 #ifdef _DEBUG
  #define CHECK_PUBLISH_CONSISTENCY { if(PublishSingleton.Busy && PublishSingleton.Text.length() > 0) {Serial.print(F("[ERROR] Attempt to writing to unclear PublishSingleton: ")); Serial.println(PublishSingleton.Text);} }
 #else
  #define CHECK_PUBLISH_CONSISTENCY (void) 0
 #endif

#define UNUSED(expr) do { (void)(expr); } while (0)

#endif
